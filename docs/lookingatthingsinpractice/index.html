<!DOCTYPE html><html lang="en" class="" style="scroll-padding:60px"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1"/><title>Using Magic Harvest in practice - Introduction</title><meta property="og:title" content="Using Magic Harvest in practice - Introduction"/><meta name="generator" content="mystmd"/><meta name="keywords" content=""/><meta name="image" content="https://klemet.github.io/Workshop-MagicHarvest/build/c46244155f82f0a2188b900fb12670c3.svg"/><meta property="og:image" content="https://klemet.github.io/Workshop-MagicHarvest/build/c46244155f82f0a2188b900fb12670c3.svg"/><link rel="stylesheet" href="https://klemet.github.io/Workshop-MagicHarvest/build/_assets/app-5WKS5EPQ.css"/><link rel="stylesheet" href="https://klemet.github.io/Workshop-MagicHarvest/build/_assets/thebe-core-VKVHG5VY.css"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jupyter-matplotlib@0.11.3/css/mpl_widget.css"/><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.css"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css" integrity="sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ" crossorigin="anonymous"/><link rel="icon" href="https://klemet.github.io/Workshop-MagicHarvest/favicon.ico"/><link rel="stylesheet" href="https://klemet.github.io/Workshop-MagicHarvest/myst-theme.css"/><script>
  const savedTheme = localStorage.getItem("myst:theme");
  const theme = window.matchMedia("(prefers-color-scheme: light)").matches ? 'light' : 'dark';
  const classes = document.documentElement.classList;
  const hasAnyTheme = classes.contains('light') || classes.contains('dark');
  if (!hasAnyTheme) classes.add(savedTheme ?? theme);
</script></head><body class="m-0 transition-colors duration-500 bg-white dark:bg-stone-900"><div class="fixed top-1 left-1 h-[0px] w-[0px] focus-within:z-40 focus-within:h-auto focus-within:w-auto bg-white overflow-hidden focus-within:p-2 focus-within:ring-1" aria-label="skip to content options"><a href="#skip-to-frontmatter" class="block px-2 py-1 text-black underline">Skip to article frontmatter</a><a href="#skip-to-article" class="block px-2 py-1 text-black underline">Skip to article content</a></div><div class="bg-white/80 backdrop-blur dark:bg-stone-900/80 shadow dark:shadow-stone-700 p-3 md:px-8 sticky w-screen top-0 z-30 h-[60px]"><nav class="flex items-center justify-between flex-nowrap max-w-[1440px] mx-auto"><div class="flex flex-row xl:min-w-[19.5rem] mr-2 sm:mr-7 justify-start items-center shrink-0"><div class="block xl:hidden"><button class="flex items-center border-stone-400 text-stone-800 hover:text-stone-900 dark:text-stone-200 hover:dark:text-stone-100"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true" data-slot="icon" width="2rem" height="2rem" class="m-1"><path fill-rule="evenodd" d="M3 6.75A.75.75 0 0 1 3.75 6h16.5a.75.75 0 0 1 0 1.5H3.75A.75.75 0 0 1 3 6.75ZM3 12a.75.75 0 0 1 .75-.75h16.5a.75.75 0 0 1 0 1.5H3.75A.75.75 0 0 1 3 12Zm0 5.25a.75.75 0 0 1 .75-.75h16.5a.75.75 0 0 1 0 1.5H3.75a.75.75 0 0 1-.75-.75Z" clip-rule="evenodd"></path></svg><span class="sr-only">Open Menu</span></button></div><a class="flex items-center ml-3 dark:text-white w-fit md:ml-5 xl:ml-7" href="https://klemet.github.io/Workshop-MagicHarvest/"><span class="text-md sm:text-xl tracking-tight sm:mr-5">Made with MyST</span></a></div><div class="flex items-center flex-grow w-auto"><div class="flex-grow hidden text-md lg:block"></div><div class="flex-grow block"></div><button type="button" aria-haspopup="dialog" aria-expanded="false" aria-controls="radix-:R74op:" data-state="closed" class="flex items-center h-10 aspect-square sm:w-64 text-left text-gray-400 border border-gray-300 dark:border-gray-600 rounded-lg bg-gray-50 dark:bg-gray-700 hover:ring-blue-500 dark:hover:ring-blue-500 hover:border-blue-500 dark:hover:border-blue-500"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true" data-slot="icon" class="p-2.5 h-10 w-10 aspect-square"><path fill-rule="evenodd" d="M10.5 3.75a6.75 6.75 0 1 0 0 13.5 6.75 6.75 0 0 0 0-13.5ZM2.25 10.5a8.25 8.25 0 1 1 14.59 5.28l4.69 4.69a.75.75 0 1 1-1.06 1.06l-4.69-4.69A8.25 8.25 0 0 1 2.25 10.5Z" clip-rule="evenodd"></path></svg><span class="hidden sm:block grow">Search</span><div aria-hidden="true" class="items-center hidden mx-1 font-mono text-sm text-gray-400 sm:flex gap-x-1"><kbd class="px-2 py-1 border border-gray-300 dark:border-gray-600 rounded-md shadow-[0px_2px_0px_0px_rgba(0,0,0,0.08)] dark:shadow-none hide-mac">CTRL</kbd><kbd class="px-2 py-1 border border-gray-300 dark:border-gray-600 rounded-md shadow-[0px_2px_0px_0px_rgba(0,0,0,0.08)] dark:shadow-none show-mac">⌘</kbd><kbd class="px-2 py-1 border border-gray-300 dark:border-gray-600 rounded-md shadow-[0px_2px_0px_0px_rgba(0,0,0,0.08)] dark:shadow-none ">K</kbd><script>
;(() => {
const script = document.currentScript;
const root = script.parentElement;

const isMac = /mac/i.test(
      window.navigator.userAgentData?.platform ?? window.navigator.userAgent,
    );
root.querySelectorAll(".hide-mac").forEach(node => {node.classList.add(isMac ? "hidden" : "block")});
root.querySelectorAll(".show-mac").forEach(node => {node.classList.add(!isMac ? "hidden" : "block")});
})()</script></div></button><button class="theme rounded-full aspect-square border border-stone-700 dark:border-white hover:bg-neutral-100 border-solid overflow-hidden text-stone-700 dark:text-white hover:text-stone-500 dark:hover:text-neutral-800 w-8 h-8 mx-3" title="Toggle theme between light and dark mode" aria-label="Toggle theme between light and dark mode"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true" data-slot="icon" class="h-full w-full p-0.5 hidden dark:block"><path fill-rule="evenodd" d="M9.528 1.718a.75.75 0 0 1 .162.819A8.97 8.97 0 0 0 9 6a9 9 0 0 0 9 9 8.97 8.97 0 0 0 3.463-.69.75.75 0 0 1 .981.98 10.503 10.503 0 0 1-9.694 6.46c-5.799 0-10.5-4.7-10.5-10.5 0-4.368 2.667-8.112 6.46-9.694a.75.75 0 0 1 .818.162Z" clip-rule="evenodd"></path></svg><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="h-full w-full p-0.5 dark:hidden"><path stroke-linecap="round" stroke-linejoin="round" d="M12 3v2.25m6.364.386-1.591 1.591M21 12h-2.25m-.386 6.364-1.591-1.591M12 18.75V21m-4.773-4.227-1.591 1.591M5.25 12H3m4.227-4.773L5.636 5.636M15.75 12a3.75 3.75 0 1 1-7.5 0 3.75 3.75 0 0 1 7.5 0Z"></path></svg></button><div class="block sm:hidden"></div><div class="hidden sm:block"></div></div></nav></div><div class="fixed xl:article-grid grid-gap xl:w-screen xl:pointer-events-none overflow-auto max-xl:min-w-[300px] hidden z-10" style="top:60px"><div class="pointer-events-auto xl:col-margin-left flex-col overflow-hidden hidden xl:flex"><div class="flex-grow py-6 overflow-y-auto primary-scrollbar"><nav aria-label="Navigation" class="overflow-y-hidden transition-opacity ml-3 xl:ml-0 mr-3 max-w-[350px] lg:hidden"><div class="w-full px-1 dark:text-white font-medium"></div></nav><div class="my-3 border-b-2 lg:hidden"></div><nav aria-label="Table of Contents" class="flex-grow overflow-y-hidden transition-opacity ml-3 xl:ml-0 mr-3 max-w-[350px]"><div class="w-full px-1 dark:text-white"><a title="Introduction" class="block break-words focus:outline outline-blue-200 outline-2 rounded p-2 my-1 rounded-lg hover:bg-slate-300/30 font-bold" href="https://klemet.github.io/Workshop-MagicHarvest/">Introduction</a><a title="How Magic Harvest Works" class="block break-words focus:outline outline-blue-200 outline-2 rounded p-2 my-1 rounded-lg hover:bg-slate-300/30" href="https://klemet.github.io/Workshop-MagicHarvest/howmagicharvestworks">How Magic Harvest Works</a><a title="Using Magic Harvest in practice" class="block break-words focus:outline outline-blue-200 outline-2 rounded p-2 my-1 rounded-lg hover:bg-slate-300/30" href="https://klemet.github.io/Workshop-MagicHarvest/lookingatthingsinpractice">Using Magic Harvest in practice</a><a title="Exercices" class="block break-words focus:outline outline-blue-200 outline-2 rounded p-2 my-1 rounded-lg hover:bg-slate-300/30" href="https://klemet.github.io/Workshop-MagicHarvest/exercises">Exercices</a><a title="Conclusion" class="block break-words focus:outline outline-blue-200 outline-2 rounded p-2 my-1 rounded-lg hover:bg-slate-300/30" href="https://klemet.github.io/Workshop-MagicHarvest/conclusion">Conclusion</a></div></nav></div><div class="flex-none py-6 transition-all duration-700 translate-y-6 opacity-0"><a class="flex mx-auto text-gray-700 w-fit hover:text-blue-700 dark:text-gray-200 dark:hover:text-blue-400" href="https://mystmd.org/made-with-myst" target="_blank" rel="noreferrer"><svg style="width:24px;height:24px" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100" stroke="none"><g id="icon"><path fill="currentColor" d="M23.8,54.8v-3.6l4.7-0.8V17.5l-4.7-0.8V13H36l13.4,31.7h0.2l13-31.7h12.6v3.6l-4.7,0.8v32.9l4.7,0.8v3.6h-15
          v-3.6l4.9-0.8V20.8H65L51.4,53.3h-3.8l-14-32.5h-0.1l0.2,17.4v12.1l5,0.8v3.6H23.8z"></path><path fill="#F37726" d="M47,86.9c0-5.9-3.4-8.8-10.1-8.8h-8.4c-5.2,0-9.4-1.3-12.5-3.8c-3.1-2.5-5.4-6.2-6.8-11l4.8-1.6
          c1.8,5.6,6.4,8.6,13.8,8.8h9.2c6.4,0,10.8,2.5,13.1,7.5c2.3-5,6.7-7.5,13.1-7.5h8.4c7.8,0,12.7-2.9,14.6-8.7l4.8,1.6
          c-1.4,4.9-3.6,8.6-6.8,11.1c-3.1,2.5-7.3,3.7-12.4,3.8H63c-6.7,0-10,2.9-10,8.8"></path></g></svg><span class="self-center ml-2 text-sm">Made with MyST</span></a></div></div></div><article class="article content article-grid grid-gap"><main class="article-grid subgrid-gap col-screen"><div class="hidden"></div><div id="skip-to-frontmatter" aria-label="article frontmatter" class="mb-8 pt-9"><div class="flex items-center h-6 mb-5 text-sm font-light"><div class="flex-grow"></div><div class="relative flex inline-block mx-1 grow-0" data-headlessui-state=""><button class="relative ml-2 -mr-1" id="headlessui-menu-button-:Rs8top:" type="button" aria-haspopup="menu" aria-expanded="false" data-headlessui-state=""><span class="sr-only">Downloads</span><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" width="1.25rem" height="1.25rem"><title>Download</title><path stroke-linecap="round" stroke-linejoin="round" d="M3 16.5v2.25A2.25 2.25 0 0 0 5.25 21h13.5A2.25 2.25 0 0 0 21 18.75V16.5M16.5 12 12 16.5m0 0L7.5 12m4.5 4.5V3"></path></svg></button></div></div><h1 class="mb-0">Using Magic Harvest in practice</h1></div><div class="block my-10 lg:sticky lg:z-10 lg:h-0 lg:pt-0 lg:my-0 lg:ml-10 lg:col-margin-right" style="top:60px"><nav></nav></div><div id="skip-to-article"></div><p><strong>Authors:</strong> Clément Hardy<sup>1</sup> <br/><strong>Affiliations:</strong> <sup>1</sup>Université du Québec en Outaouais (UQO)\</p><p><a target="_blank" rel="noreferrer" href="https://myst.tools" class=""><img id="YqOcIEP9Eh" style="margin:0 auto" src="https://klemet.github.io/Workshop-MagicHarvest/build/c46244155f82f0a2188b900fb12670c3.svg" alt="Made with MyST" data-canonical-url="https://img.shields.io/badge/made%20with-myst-orange" class=""/></a></p><h2 id="getting-on-the-field" class="relative group"><span class="heading-text">Getting on the field !</span><a class="no-underline text-inherit hover:text-inherit inline-block w-0 px-0 translate-x-[10px] font-normal select-none transition-opacity opacity-0 focus:opacity-100 group-hover:opacity-70" href="#getting-on-the-field" title="Link to this Section" aria-label="Link to this Section">¶</a></h2><p><img id="gfQzzSxkKI" style="margin:0 auto" src="https://klemet.github.io/Workshop-MagicHarvest/build/Slide22-73c8c73f4090d7070e99455087488fa6.jpg" data-canonical-url="./images/Slide22.jpg" class=""/></p><p>Here, we’re going to see the more technical details of using Magic Harvest :</p><ul><li>How to access the state of the LANDIS-II landscape in a Python or R script run with Magic Harvest ?</li><li>How to edit the parameter files of Biomass Harvest to control harvesting ?</li><li>Etc.</li></ul><h2 id="looking-at-some-example-files-for-a-simple-simulation" class="relative group"><span class="heading-text">Looking at some example files for a simple simulation</span><a class="no-underline text-inherit hover:text-inherit inline-block w-0 px-0 translate-x-[10px] font-normal select-none transition-opacity opacity-0 focus:opacity-100 group-hover:opacity-70" href="#looking-at-some-example-files-for-a-simple-simulation" title="Link to this Section" aria-label="Link to this Section">¶</a></h2><p><img id="QJ9dwHGTor" style="margin:0 auto" src="https://klemet.github.io/Workshop-MagicHarvest/build/Slide23-5ca2a1b88a420b071221934f4703621c.jpg" data-canonical-url="./images/Slide23.jpg" class=""/></p><p>First of all, I’m going to show you some screenshots of a test scenario with Magic Harvest, with <a target="_blank" rel="noreferrer" href="https://github.com/Klemet/LANDIS-II-Magic-Harvest/tree/main/Examples/Core-v8/Biomass%20Harvest" class="">the test files that are on the repository of Magic Harvest</a>. Just so that you have a visual idea of what it looks like in action.</p><p>Here is the scenario file that we have quickly seen before; as you see, Magic Harvest is indicated before B. Harvest, and the disturbance order is not random. The path points to the parameter text file of magic harvest. Here is the magic harvest parameter file, that we also have seen before; it’s very simple, and launches a Python script that simply switches the name of files to activate a different B. Harvest parameter text files.</p><hr class="py-2 my-5 translate-y-2"/><p><img id="UDyMNEkIUU" style="margin:0 auto" src="https://klemet.github.io/Workshop-MagicHarvest/build/Slide24-0363552cdcd396d343797d282e95cce4.jpg" data-canonical-url="./images/Slide24.jpg" class=""/></p><p>Here is the Python script launched by Magic Harvest everytime it runs. You see, it’s very simple. It simply renames files to switch between two sets of input files for B. Harvest. This is one of the simplest ways you can influence B. Harvest; you don’t even edit files, you just switch them.</p><hr class="py-2 my-5 translate-y-2"/><p><img id="C4RMDR8JyR" style="margin:0 auto" src="https://klemet.github.io/Workshop-MagicHarvest/build/Slide25-c79d8511ec0c378a77ce582c13dff7b5.jpg" data-canonical-url="./images/Slide25.jpg" class=""/></p><p>And finally, here is the log of LANDIS-II when it is running. As you see, Magic Harvest writes in the log when it activates, when it’s done running, and when it re-loads the parameters of B. Harvest. We can even see the “print” statements that come from the Python script, and which indicate what the script is doing ! <strong>This is great for debugging</strong>. If B. Harvest is not installed or used in the simulation, Magic Harvest will warn you of it.</p><aside class="myst-admonition myst-admonition-caution my-5 shadow-md dark:shadow-2xl dark:shadow-neutral-900 bg-gray-50/10 dark:bg-stone-800 overflow-hidden myst-admonition-default rounded border-l-4 border-amber-600"><div class="myst-admonition-header m-0 font-medium py-1 flex min-w-0 text-lg text-amber-600 bg-amber-50 dark:bg-slate-900"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" width="2rem" height="2rem" class="myst-admonition-header-icon inline-block pl-2 mr-2 self-center flex-none text-amber-600"><path stroke-linecap="round" stroke-linejoin="round" d="M12 9v3.75m9-.75a9 9 0 1 1-18 0 9 9 0 0 1 18 0Zm-9 3.75h.008v.008H12v-.008Z"></path></svg><div class="myst-admonition-header-text text-neutral-900 dark:text-white grow self-center overflow-hidden break-words">Caution</div></div><div class="myst-admonition-body px-4 py-1"><p>The print statements from your R or Python script will not be recorded in the LANDIS-II log text file that LANDIS-II generates during the simulation. But they will be seen in your console.</p></div></aside><h2 id="taking-a-look-at-a-python-script-template" class="relative group"><span class="heading-text">Taking a look at a Python script template</span><a class="no-underline text-inherit hover:text-inherit inline-block w-0 px-0 translate-x-[10px] font-normal select-none transition-opacity opacity-0 focus:opacity-100 group-hover:opacity-70" href="#taking-a-look-at-a-python-script-template" title="Link to this Section" aria-label="Link to this Section">¶</a></h2><p><img id="eahjidnIgA" style="margin:0 auto" src="https://klemet.github.io/Workshop-MagicHarvest/build/Slide26-ffb0aa62ca811d037b33e7353568a6f4.jpg" data-canonical-url="./images/Slide26.jpg" class=""/></p><p>Now, I’m going to show you a “template” of a Python script I’ve been using in my PhD thesis and my post-doctoral work. This template reads the state of the landscape and other things, and then writes some files to give to B. Harvest. The rest (the management decisions based on the state of the landscape) are up to you to write. We’ll use this template as a base for the following exercice. <a target="_blank" rel="noreferrer" href="https://klemet.github.io/Workshop-MagicHarvest/build/magicHarvest_pythonT-5e3c65352679e040f1cbfb63112fd97b.py" class="">You can download the full file here</a>.</p><p>So first off, a warning : <strong>the template I’m about to show you is complex</strong>, even though I have removed any management decisions. You have to understand that I’ve spent years working on this script through two chapters of my thesis, and then my post-doc work. It’s full of functions made to do things quickly and in an optimized way. It’s also made to adapt to the pretty complex forms of management decision I’ve been making. So what I am about to show you is going to be overwelming. As such, <strong>I propose that you to not try to understand or read or remember everything</strong>. In the future, you might use this template for your own work; it is very heavily commented, and you will have the time to understand it piece by piece. <strong>Here, I simply want to give you a glimpse under the hood to show you what the engine can look like</strong>.</p><p>You might also feel like it’s not normal for this methodology to get this complicated; that Magic Harvest is nice, but that this is just too much work and complexity. It’s something I have often felt when working on this. But here, we are working a trade-off : Magic Harvest allow us to become free from the restrictive and pre-defined algorithms of LANDIS-II and do whatever we want, which is essential to our research; but the trade-off is that we have to write the code for that, and it gets complex; just like the code inside LANDIS-II is. It’s just that usually, we don’t touch the LANDIS-II code as users. Here, we have to code everything. That’s the trade-off.</p><p>We could, of course, code a whole new harvest extension for LANDIS-II instead of using a script like this; but this become restrictive again because you have to deal with the complex building process of extensions in the C# langage that LANDIS-II uses, you have to maintain them, and then future users become restricted by your algorithm. By using R or Python scripts, we can use simpler programming langages that most ecologist know to some degree, and we can share our scripts easily, and they can be re-used easily. So, no solution is perfect; but while this one is complex, it works realiably and gives us a high level of control.</p><p>So, ready ? Let’s dig in.</p><h3 id="defining-functions-for-everything" class="relative group"><span class="heading-text">Defining functions for everything</span><a class="no-underline text-inherit hover:text-inherit inline-block w-0 px-0 translate-x-[10px] font-normal select-none transition-opacity opacity-0 focus:opacity-100 group-hover:opacity-70" href="#defining-functions-for-everything" title="Link to this Section" aria-label="Link to this Section">¶</a></h3><p>The beginning of this template is simply a section where a lot of functions are defined so that we can use them afterwards. I really advise you define functions like this. It makes the rest of the code much clearer. In Python, it is really easy to describe each function you’re writting, in particular its inputs and outputs, via a “docstring”, a string of text that documents the function. Modern text editors allow you to write it quickly. AI can write it for you too.</p><p>Here is an example in the script :</p><div class="relative myst-code group not-prose my-5 text-sm shadow hover:shadow-md dark:shadow-2xl dark:shadow-neutral-900 bg-stone-200/10"><pre class="block overflow-auto p-3 myst-code-body hljs" style="background-color:unset"><code class="language-python" style="white-space:pre">def readingStandsCoordinates(standRasterDataAll, disableTQDM):
    &#x27;&#x27;&#x27;Reads the stands map to get the coordinates of each pixel in a stand.
    Returns a dictionnary giving the coordinates for each pixel for a given
    stand ID. Locations are in (row, column) tuple format, as necessary to
    access a value in a numpy array made from a raster by Rasterio.
    standRasterDataAll must be a numpy array contained the data from your raster map.&#x27;&#x27;&#x27;
    print(&quot;Reading stands coordinates...&quot;)
    standCoordinatesDict = dict()
    uniqueAllStandsID = np.unique(standRasterDataAll).tolist()
    # id 0 for stands = no forests
    uniqueAllStandsID.remove(0)
    for standID in tqdm(uniqueAllStandsID, disable = disableTQDM):
        # print(standID)
        standCoordinatesDict[standID] = list()
    for x in tqdm(range(standRasterDataAll.shape[0]), disable = disableTQDM):
        for y in range(standRasterDataAll.shape[1]):
            standID = standRasterDataAll[(x, y)]
            if standID != 0:
                standCoordinatesDict[standID].append((x, y))
    return(standCoordinatesDict)</code></pre><button title="Copy to Clipboard" class="inline-flex items-center opacity-0 group-hover:opacity-100 hover:opacity-100 focus:opacity-100 active:opacity-100 cursor-pointer ml-2 transition-color duration-200 ease-in-out text-blue-400 hover:text-blue-500 absolute right-1 myst-code-copy-icon top-1" aria-pressed="false" aria-label="Copy code to clipboard"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" width="24" height="24"><path stroke-linecap="round" stroke-linejoin="round" d="M15.75 17.25v3.375c0 .621-.504 1.125-1.125 1.125h-9.75a1.125 1.125 0 0 1-1.125-1.125V7.875c0-.621.504-1.125 1.125-1.125H6.75a9.06 9.06 0 0 1 1.5.124m7.5 10.376h3.375c.621 0 1.125-.504 1.125-1.125V11.25c0-4.46-3.243-8.161-7.5-8.876a9.06 9.06 0 0 0-1.5-.124H9.375c-.621 0-1.125.504-1.125 1.125v3.5m7.5 10.375H9.375a1.125 1.125 0 0 1-1.125-1.125v-9.25m12 6.625v-1.875a3.375 3.375 0 0 0-3.375-3.375h-1.5a1.125 1.125 0 0 1-1.125-1.125v-1.5a3.375 3.375 0 0 0-3.375-3.375H9.75"></path></svg></button></div><p>There’s a lot of functions here. The first ones are used to easily read and write raster map data. When we read raster map data, we put it in a “numpy” array - numpy being a very famous Python package that allows for extremely efficient vectorial, matricial, or generally multi-dimensional array computation. So we put the values of the raster in a 2-dimensional array.</p><div class="relative myst-code group not-prose my-5 text-sm shadow hover:shadow-md dark:shadow-2xl dark:shadow-neutral-900 bg-stone-200/10"><pre class="block overflow-auto p-3 myst-code-body hljs" style="background-color:unset"><code class="language-python" style="white-space:pre">def getRasterData(path):
    raster = gdal.Open(path)
    rasterData = raster.GetRasterBand(1)
    rasterData = rasterData.ReadAsArray()
    return(np.array(rasterData))
	
def getRasterDataAsList(path):
    return(getRasterData(path).tolist())

def writeNewRasterData(rasterDataArray, pathOfTemplateRaster, pathOfOutput):
    # Saves a raster in int16 with a nodata value of 0
    # Inspired from https://gis.stackexchange.com/questions/164853/reading-modifying-and-writing-a-geotiff-with-gdal-in-python
    # Loading template raster
    template = gdal.Open(pathOfTemplateRaster)
    driver = gdal.GetDriverByName(&quot;GTiff&quot;)
    [rows, cols] = template.GetRasterBand(1).ReadAsArray().shape
    outputRaster = driver.Create(pathOfOutput, cols, rows, 1, gdal.GDT_Int16)
    outputRaster.SetGeoTransform(template.GetGeoTransform())##sets same geotransform as input
    outputRaster.SetProjection(template.GetProjection())##sets same projection as input
    outputRaster.GetRasterBand(1).WriteArray(rasterDataArray)
    outputRaster.GetRasterBand(1).SetNoDataValue(0)##if you want these values transparent
    outputRaster.FlushCache() ##saves to disk!!
    outputRaster = None
    
def writeNewRasterDataFloat32(rasterDataArray, pathOfTemplateRaster, pathOfOutput):
    # Saves a raster in Float32 with a nodata value of 0.0
    # Inspired from https://gis.stackexchange.com/questions/164853/reading-modifying-and-writing-a-geotiff-with-gdal-in-python
    # Loading template raster
    template = gdal.Open(pathOfTemplateRaster)
    driver = gdal.GetDriverByName(&quot;GTiff&quot;)
    [rows, cols] = template.GetRasterBand(1).ReadAsArray().shape
    outputRaster = driver.Create(pathOfOutput, cols, rows, 1, gdal.GDT_Float32)
    outputRaster.SetGeoTransform(template.GetGeoTransform())##sets same geotransform as input
    outputRaster.SetProjection(template.GetProjection())##sets same projection as input
    outputRaster.GetRasterBand(1).WriteArray(rasterDataArray)
    outputRaster.GetRasterBand(1).SetNoDataValue(0)##if you want these values transparent
    outputRaster.FlushCache() ##saves to disk!!
    outputRaster = None

def writeExistingRasterData(rasterDataArray, pathOfRasterToEdit):
    # Edits the data of an existing raster
    rasterToEdit = gdal.Open(pathOfRasterToEdit, gdal.GF_Write)
    rasterToEdit.GetRasterBand(1).WriteArray(rasterDataArray)
    rasterToEdit.FlushCache() ##saves to disk!!
    rasterToEdit = None</code></pre><button title="Copy to Clipboard" class="inline-flex items-center opacity-0 group-hover:opacity-100 hover:opacity-100 focus:opacity-100 active:opacity-100 cursor-pointer ml-2 transition-color duration-200 ease-in-out text-blue-400 hover:text-blue-500 absolute right-1 myst-code-copy-icon top-1" aria-pressed="false" aria-label="Copy code to clipboard"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" width="24" height="24"><path stroke-linecap="round" stroke-linejoin="round" d="M15.75 17.25v3.375c0 .621-.504 1.125-1.125 1.125h-9.75a1.125 1.125 0 0 1-1.125-1.125V7.875c0-.621.504-1.125 1.125-1.125H6.75a9.06 9.06 0 0 1 1.5.124m7.5 10.376h3.375c.621 0 1.125-.504 1.125-1.125V11.25c0-4.46-3.243-8.161-7.5-8.876a9.06 9.06 0 0 0-1.5-.124H9.375c-.621 0-1.125.504-1.125 1.125v3.5m7.5 10.375H9.375a1.125 1.125 0 0 1-1.125-1.125v-9.25m12 6.625v-1.875a3.375 3.375 0 0 0-3.375-3.375h-1.5a1.125 1.125 0 0 1-1.125-1.125v-1.5a3.375 3.375 0 0 0-3.375-3.375H9.75"></path></svg></button></div><p>Then, we have functions that read the state and structure of the landscape in LANDIS-II. To do that, we use input and output raster maps and files from LANDIS-II that will be in our simulation folder. Of course, when LANDIS-II runs, it has its own internal variables that contain the information on the landscape; but sadly, we cannot access these. These variables are contained in the RAM of your computer, and they are only accessible to the program. Since the script we are using is outside LANDIS-II - it’s run through Python, not LANDIS-II -, then we cannot access these internal variables of LANDIS-II.</p><p>But that’s fine, because we can use output extensions and some input files of LANDIS-II to get everything we need.</p><p>For example, to get the forest stands in the landscape, we can read the map of forest stands - the one that is usually given to B. Harvest.</p><div class="relative myst-code group not-prose my-5 text-sm shadow hover:shadow-md dark:shadow-2xl dark:shadow-neutral-900 bg-stone-200/10"><pre class="block overflow-auto p-3 myst-code-body hljs" style="background-color:unset"><code class="language-python" style="white-space:pre">def readingStandsCoordinates(standRasterDataAll, disableTQDM):
    &#x27;&#x27;&#x27;Reads the stands map to get the coordinates of each pixel in a stand.
    Returns a dictionnary giving the coordinates for each pixel for a given
    stand ID. Locations are in (row, column) tuple format, as necessary to
    access a value in a numpy array made from a raster by Rasterio.
    standRasterDataAll must be a numpy array contained the data from your raster map.&#x27;&#x27;&#x27;
    print(&quot;Reading stands coordinates...&quot;)
    standCoordinatesDict = dict()
    uniqueAllStandsID = np.unique(standRasterDataAll).tolist()
    # id 0 for stands = no forests
    uniqueAllStandsID.remove(0)
    for standID in tqdm(uniqueAllStandsID, disable = disableTQDM):
        # print(standID)
        standCoordinatesDict[standID] = list()
    for x in tqdm(range(standRasterDataAll.shape[0]), disable = disableTQDM):
        for y in range(standRasterDataAll.shape[1]):
            standID = standRasterDataAll[(x, y)]
            if standID != 0:
                standCoordinatesDict[standID].append((x, y))
    return(standCoordinatesDict)</code></pre><button title="Copy to Clipboard" class="inline-flex items-center opacity-0 group-hover:opacity-100 hover:opacity-100 focus:opacity-100 active:opacity-100 cursor-pointer ml-2 transition-color duration-200 ease-in-out text-blue-400 hover:text-blue-500 absolute right-1 myst-code-copy-icon top-1" aria-pressed="false" aria-label="Copy code to clipboard"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" width="24" height="24"><path stroke-linecap="round" stroke-linejoin="round" d="M15.75 17.25v3.375c0 .621-.504 1.125-1.125 1.125h-9.75a1.125 1.125 0 0 1-1.125-1.125V7.875c0-.621.504-1.125 1.125-1.125H6.75a9.06 9.06 0 0 1 1.5.124m7.5 10.376h3.375c.621 0 1.125-.504 1.125-1.125V11.25c0-4.46-3.243-8.161-7.5-8.876a9.06 9.06 0 0 0-1.5-.124H9.375c-.621 0-1.125.504-1.125 1.125v3.5m7.5 10.375H9.375a1.125 1.125 0 0 1-1.125-1.125v-9.25m12 6.625v-1.875a3.375 3.375 0 0 0-3.375-3.375h-1.5a1.125 1.125 0 0 1-1.125-1.125v-1.5a3.375 3.375 0 0 0-3.375-3.375H9.75"></path></svg></button></div><p>For informations about the harvest prescriptions, we can simple “parse” the B. Harvest parameters text file. This is a bit more tricky, but the function is already there, and allows us to put all informations into a Python dictionnary. The dictionnaries of Python is an object that I love very much and use very often : it simply associate an object (e.g. a number, a sentence or a word, or any other object) with another. Here, by reading the harvest parameter text file, I created a big dictionnary that contains the information and rules about each prescription in there. This can be useful, for example, to estimate how much biomass these prescription will harvest in the cells. Making this estimation can be used to know if we have reached the targets we have for the current timestep.</p><div class="relative myst-code group not-prose my-5 text-sm shadow hover:shadow-md dark:shadow-2xl dark:shadow-neutral-900 bg-stone-200/10"><pre class="block overflow-auto p-3 myst-code-body hljs" style="background-color:unset"><code class="language-python" style="white-space:pre">def harvestParameterFileParser(path):
    &quot;&quot;&quot;
    Parses the biomass harvest parameter file at the given path.
    Returns a dictionnary with the needed parameters.
    
    WARNING : To read the harvest file properly, make sure to :
    - Not use relative number of cohorts harvested for a given species, like
      &quot;1/2&quot; or &quot;1/3&quot;. Since this script is made to be used with biomass harvest,
      use things like &quot;11-999(50%)&quot; to harvest half of the biomass of each cohort.
    - Make sure the biomass percentages are not separated from their respective
      age class, meaning write &quot;11-999(50%)&quot; rather than &quot;11-999 (50%)&quot;
    &quot;&quot;&quot;
    print(&quot;Reading harvest parameter file...&quot;)
    
    dictToReturn = dict()
    
    # WARNING : Here is the list of species I use. Replace it with your own species
    # codes that you use in LANDIS-II !
    speciesList = [&quot;ABIE.BAL&quot;,&quot;ACER.RUB&quot;,&quot;ACER.SAH&quot;,&quot;BETU.ALL&quot;,&quot;BETU.PAP&quot;,
                   &quot;FAGU.GRA&quot;,&quot;LARI.LAR&quot;,&quot;LARI.HYB&quot;,&quot;PICE.GLA&quot;,&quot;PICE.MAR&quot;,
                   &quot;PICE.RUB&quot;,&quot;PINU.BAN&quot;,&quot;PINU.RES&quot;,&quot;PINU.STR&quot;,&quot;POPU.TRE&quot;,
                   &quot;POPU.HYB&quot;,&quot;QUER.RUB&quot;,&quot;THUJ.SPP.ALL&quot;,&quot;TSUG.CAN&quot;]
    
    with open(path, &#x27;r&#x27;) as file:
        prescriptionSelected = &quot;none&quot;
        prescriptionID = 1 # We start at 1 because the ID is for the raster;
        # 0 = not forest, 1 = forest not harvested, and then it&#x27;s the prescriptions.
        for line in file:
            # print(line)
            # We start by recording the lines if we&#x27;re reading a prescription
            if prescriptionSelected != &quot;none&quot; and &quot;Prescription &quot; not in line:
                dictToReturn[prescriptionSelected][&quot;FullString&quot;].append(line)
            if &quot;&gt;&gt;-------------&quot; in line:
                prescriptionSelected = &quot;none&quot;
                
            # We get the timestep used by the extension
            if &quot;Timestep&quot; in line:
                timestepLength = int(splitLineAndRemoveTabsAndSpaces(line)[1])
            # If we find a new prescription, we initialize everything needed
            if &quot;Prescription &quot; in line:
                prescriptionSelected = line[len(&quot;Prescription &quot;):-1] #-1 removes the \n character at the end of each line
                if prescriptionSelected not in dictToReturn:
                    dictToReturn[prescriptionSelected] = dict()
                    dictToReturn[prescriptionSelected][&quot;Planting&quot;] = &quot;none&quot;
                    dictToReturn[prescriptionSelected][&quot;RepeatMode&quot;] = &quot;none&quot;
                    dictToReturn[prescriptionSelected][&quot;MaximumStandAge&quot;] = 999
                    dictToReturn[prescriptionSelected][&quot;MinimumStandAge&quot;] = 0
                    dictToReturn[prescriptionSelected][&quot;Commercial&quot;] = True # Does it generate merchantable wood ?
                    dictToReturn[prescriptionSelected][&quot;FullString&quot;] = [line] # We keep all the lines of the prescription to be able to copy it to make different plantings
                    prescriptionID += 1
                    dictToReturn[&quot;_MaxPrescriptionID&quot;] = prescriptionID # Special counter used to create new planting prescriptions later
                    dictToReturn[prescriptionSelected][&quot;PrescriptionID&quot;] = prescriptionID
                singleRepeat = False
            
            # Else, we register the parameters of the prescription
            elif &quot;MaximumAge&quot; in line:
                maximumAge = splitLineAndRemoveTabsAndSpaces(line)[1]
                dictToReturn[prescriptionSelected][&quot;MaximumStandAge&quot;] = int(maximumAge)
            elif &quot;MinimumAge&quot; in line:
                minimumAge = splitLineAndRemoveTabsAndSpaces(line)[1]
                dictToReturn[prescriptionSelected][&quot;MinimumStandAge&quot;] = int(minimumAge)
            elif &quot;SiteSelection&quot; in line:
                # The line contains 2 words + the two numerical values we want
                # We remove everything we don&#x27;t need to get the two values
                splittedLine = splitLineAndRemoveTabsAndSpaces(line)
                # print(splittedLine)
                dictToReturn[prescriptionSelected][&quot;HarvestPropagation&quot;] = [float(splittedLine[2]), float(splittedLine[3])]
            elif &quot;CohortsRemoved&quot; in line and not singleRepeat:
                dictToReturn[prescriptionSelected][&quot;CohortRemoved&quot;] = dict()
            elif &quot;Planting&quot; in line:
                plantingString = splitLineAndRemoveTabsAndSpaces(line)[1]
                dictToReturn[prescriptionSelected][&quot;Planting&quot;] = plantingString
            elif &quot;Commercial&quot; in line and &quot;FALSE&quot; in line.upper():
                dictToReturn[prescriptionSelected][&quot;Commercial&quot;] = False
            elif &quot;SingleRepeat&quot; in line:
                singleRepeat = True
                dictToReturn[prescriptionSelected][&quot;CohortRemoved&quot;][&quot;SingleRepeat&quot;] = dict()
                dictToReturn[prescriptionSelected][&quot;RepeatMode&quot;] = &quot;SingleRepeat&quot;
                repeatFrenquency = splitLineAndRemoveTabsAndSpaces(line)[1]
                dictToReturn[prescriptionSelected][&quot;RepeatFrequency&quot;] = int(repeatFrenquency)
            elif &quot;MultipleRepeat&quot; in line:
                dictToReturn[prescriptionSelected][&quot;RepeatMode&quot;] = &quot;MultipleRepeat&quot;
                repeatFrenquency = splitLineAndRemoveTabsAndSpaces(line)[1]
                dictToReturn[prescriptionSelected][&quot;RepeatFrequency&quot;] = int(repeatFrenquency)
                
            # If we get to the part about the cohort removed, it&#x27;s a bit more tricky
            # to register
            # In particular, we will register the cohort removed in the case of a
            # second pass (via SingleRepeat) in a different nested dictionnary
            for species in speciesList:
                if species in line and &quot;Prescription &quot; not in line and &quot;Plant&quot; not in line:
                    if not singleRepeat:
                        dictToReturn[prescriptionSelected][&quot;CohortRemoved&quot;][species] = dict()
                    else:
                        dictToReturn[prescriptionSelected][&quot;CohortRemoved&quot;][&quot;SingleRepeat&quot;][species] = dict()
                    # 3 cases :
                    # just ages (11-999)
                    # &quot;All&quot; keyword
                    # ages categories with biomass percent (11-999(90%))
                    # print(line)
                    if &quot;/&quot; in line: # Just in case their are relative cohort numbers in the file
                        raise ValueError(&quot;Do not use relative number of cohort harvested for a given species, like \&quot;1/2\&quot; or \&quot;1/3\&quot;. Since this script is made to be used with biomass harvest, use things like \&quot;11-999(50%)\&quot; to harvest half of the biomass of each cohort.&quot;)
                    elif &quot;All&quot; in line or &quot;all&quot; in line:
                        if not singleRepeat:
                            dictToReturn[prescriptionSelected][&quot;CohortRemoved&quot;][species] = &quot;All&quot;
                        else:
                            dictToReturn[prescriptionSelected][&quot;CohortRemoved&quot;][&quot;SingleRepeat&quot;][species] = &quot;All&quot;
                    else: # If not all, we have to break appart the age categories
                        if not singleRepeat:
                            dictToReturn[prescriptionSelected][&quot;CohortRemoved&quot;][species] = list()
                        else:
                            dictToReturn[prescriptionSelected][&quot;CohortRemoved&quot;][&quot;SingleRepeat&quot;][species] = list()
                        splittedLine = splitLineAndRemoveTabsAndSpaces(line)
                        # print(splittedLine)
                        for ageCategory in splittedLine[1:]:
                            if &quot;%&quot; not in ageCategory:
                                splitAgeCategory = ageCategory.split(&quot;-&quot;)
                                # We add a list describing 1) min age of category 2) max age of category 3) % of biomass harvested
                                if not singleRepeat:
                                    dictToReturn[prescriptionSelected][&quot;CohortRemoved&quot;][species].append([int(splitAgeCategory[0]), int(splitAgeCategory[1]), 100])
                                else:
                                    dictToReturn[prescriptionSelected][&quot;CohortRemoved&quot;][&quot;SingleRepeat&quot;][species].append([int(splitAgeCategory[0]), int(splitAgeCategory[1]), 100])
                            else:
                                splitAgeCategory = ageCategory.replace(&quot;(&quot;, &quot;-&quot;).replace(&quot;%)&quot;, &quot;&quot;).split(&quot;-&quot;)
                                if not singleRepeat:
                                    dictToReturn[prescriptionSelected][&quot;CohortRemoved&quot;][species].append([int(splitAgeCategory[0]), int(splitAgeCategory[1]), int(splitAgeCategory[2])])
                                else:
                                    dictToReturn[prescriptionSelected][&quot;CohortRemoved&quot;][&quot;SingleRepeat&quot;][species].append([int(splitAgeCategory[0]), int(splitAgeCategory[1]), int(splitAgeCategory[2])])
                        
            if &quot;HarvestImplementations&quot; in line:
                break
                
    return(dictToReturn, timestepLength)</code></pre><button title="Copy to Clipboard" class="inline-flex items-center opacity-0 group-hover:opacity-100 hover:opacity-100 focus:opacity-100 active:opacity-100 cursor-pointer ml-2 transition-color duration-200 ease-in-out text-blue-400 hover:text-blue-500 absolute right-1 myst-code-copy-icon top-1" aria-pressed="false" aria-label="Copy code to clipboard"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" width="24" height="24"><path stroke-linecap="round" stroke-linejoin="round" d="M15.75 17.25v3.375c0 .621-.504 1.125-1.125 1.125h-9.75a1.125 1.125 0 0 1-1.125-1.125V7.875c0-.621.504-1.125 1.125-1.125H6.75a9.06 9.06 0 0 1 1.5.124m7.5 10.376h3.375c.621 0 1.125-.504 1.125-1.125V11.25c0-4.46-3.243-8.161-7.5-8.876a9.06 9.06 0 0 0-1.5-.124H9.375c-.621 0-1.125.504-1.125 1.125v3.5m7.5 10.375H9.375a1.125 1.125 0 0 1-1.125-1.125v-9.25m12 6.625v-1.875a3.375 3.375 0 0 0-3.375-3.375h-1.5a1.125 1.125 0 0 1-1.125-1.125v-1.5a3.375 3.375 0 0 0-3.375-3.375H9.75"></path></svg></button></div><p>Now, I’ve shown a function to read the stands, and one to read the B. Harvest parameter text file; but how do we get the vegetation data ? How do we know exactly what’s inside each cell in the landscape ? The age cohorts and their biomass ? Took me a while, but I found a great way. There is an output extension called <a target="_blank" rel="noreferrer" href="https://github.com/LANDIS-II-Foundation/Extension-Output-Biomass-Community" class="">Biomass Community Output</a> that, at each time step, exports the entire landscape as a raster map + a communities csv file that is exactly like the ones that are used for the initial conditions of LANDIS-II. These files are very large, as they contain the most “raw” data that LANDIS-II can output. But with a bit of optimisation, Python can read them very quickly and put them into a dictionnary. In this dictionnary, we can access the age cohorts of each pixels of a given stand, their age, and their biomass. That gives us all of the information we will ever need to make management decisions.</p><div class="relative myst-code group not-prose my-5 text-sm shadow hover:shadow-md dark:shadow-2xl dark:shadow-neutral-900 bg-stone-200/10"><pre class="block overflow-auto p-3 myst-code-body hljs" style="background-color:unset"><code class="language-python" style="white-space:pre">def readCommunitiesComplete(communityCsvPath,
                            communityMapPath,
                            standCoordinatesDict,
                            disableTQDM):
    &quot;&quot;&quot;
    Reads the communities csv and raster map made by Output Biomass Community
    to make a dictionnary containing the species and age cohorts for each
    species and biomass for these cohorts for all of the pixels of a stand.
    WARNING : the dictionnary doesn&#x27;t contain entries for stands that have
    no cohorts/no biomass, and no entries for species that are not in a stand
    or cohorts that do not exist for a species. This saves on a lot of space,
    but one got to check if the entries are there when using the dictionnary.
    &quot;&quot;&quot;

    # communityCsvPath = &quot;./community-input-file-&quot; + str(timestep) + &quot;.csv&quot;
    # communityMapPath = &quot;./output-community-&quot; + str(timestep) + &quot;.img&quot;
    print(&quot;Reading communities csv and map...&quot;)
    # We only need the mapcode column from the csv from now.
    communityCsv = pd.read_csv(communityCsvPath, usecols=[&#x27;MapCode&#x27;])
    communityMapCodeData = getRasterData(communityMapPath)

    # We make the dictionnary of the amount of times a stand is associated
    # to a mapcode
    print(&quot;Creating mapcode community dictionnary...&quot;)
    dictMapCodeStands = dict()
    for uniqueMapCode in communityCsv[&quot;MapCode&quot;].unique():
        dictMapCodeStands[uniqueMapCode] = dict()
        
    for standID in standCoordinatesDict.keys():
        for pixel in standCoordinatesDict[standID]:
            mapcode = communityMapCodeData[pixel]
            # If the mapcode is not already in the dictionnary, it was not in
            # the CSV; and if it&#x27;s not in the CSV, it&#x27;s because it&#x27;s a mapcode
            # associated to no cohorts at all(total biomass of 0)
            if mapcode in dictMapCodeStands:
                if standID not in dictMapCodeStands[mapcode]:
                    dictMapCodeStands[mapcode][standID] = 1
                else:
                    dictMapCodeStands[mapcode][standID] += 1
    
    # Now, we can read the CSV file and fill in a second dictionnary with the
    # information for each stand
    # To lighten it, we won&#x27;t put stands that have no biomass
    # (IMPORTANT FOR OTHER FUNCTIONS : have to check if stand is in dictionnary)
    print(&quot;Creating stand community dictionnary...&quot;)
    
    standCommunitiesDict = dict()
    with open(communityCsvPath, &#x27;r&#x27;) as file:
        reader = csv.reader(file)
        headers = next(reader)  # Read the header row
        for row in tqdm(reader, total=len(communityCsv[&quot;MapCode&quot;]), disable = disableTQDM):
            # 0 is mapcode; 1 is species; 2 is cohort; 3 is biomass.
            for standID in dictMapCodeStands[int(row[0])]:
                if standID not in standCommunitiesDict:
                    standCommunitiesDict[standID] = dict()
                    standCommunitiesDict[standID][row[1]] = dict()
                    standCommunitiesDict[standID][row[1]][int(row[2])] = 0
                # If species not indicated for this stand, we put it
                elif row[1] not in standCommunitiesDict[standID]:
                    standCommunitiesDict[standID][row[1]] = dict()
                    standCommunitiesDict[standID][row[1]][int(row[2])] = 0
                # If age cohort not indicated for this stand/species, we put it
                elif int(row[2]) not in standCommunitiesDict[standID][row[1]]:
                    standCommunitiesDict[standID][row[1]][int(row[2])] = 0
                # Finally, we enter the biomass for the stand/species/cohort
                # If the stand has multiple pixel with this mapcode, we multiply
                # the biomass with the number of pixels
                # WARNING : Need to transform biomass from g/m2 to Mg/ha by dividing by 100
                standCommunitiesDict[standID][row[1]][int(row[2])] += (int(row[3])/100)*dictMapCodeStands[int(row[0])][standID]
        
    return(standCommunitiesDict)</code></pre><button title="Copy to Clipboard" class="inline-flex items-center opacity-0 group-hover:opacity-100 hover:opacity-100 focus:opacity-100 active:opacity-100 cursor-pointer ml-2 transition-color duration-200 ease-in-out text-blue-400 hover:text-blue-500 absolute right-1 myst-code-copy-icon top-1" aria-pressed="false" aria-label="Copy code to clipboard"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" width="24" height="24"><path stroke-linecap="round" stroke-linejoin="round" d="M15.75 17.25v3.375c0 .621-.504 1.125-1.125 1.125h-9.75a1.125 1.125 0 0 1-1.125-1.125V7.875c0-.621.504-1.125 1.125-1.125H6.75a9.06 9.06 0 0 1 1.5.124m7.5 10.376h3.375c.621 0 1.125-.504 1.125-1.125V11.25c0-4.46-3.243-8.161-7.5-8.876a9.06 9.06 0 0 0-1.5-.124H9.375c-.621 0-1.125.504-1.125 1.125v3.5m7.5 10.375H9.375a1.125 1.125 0 0 1-1.125-1.125v-9.25m12 6.625v-1.875a3.375 3.375 0 0 0-3.375-3.375h-1.5a1.125 1.125 0 0 1-1.125-1.125v-1.5a3.375 3.375 0 0 0-3.375-3.375H9.75"></path></svg></button></div><p>We then have other functions that can retrieve data we might need for management decisions. These functions used objects created by other functions that contain data about the vegetation. For example :</p><ul><li>Getting the biomass of a list of species we want to harvest in a stand (based on the vegetation data we have put in a dictionnary)</li></ul><div class="relative myst-code group not-prose my-5 text-sm shadow hover:shadow-md dark:shadow-2xl dark:shadow-neutral-900 bg-stone-200/10"><pre class="block overflow-auto p-3 myst-code-body hljs" style="background-color:unset"><code class="language-python" style="white-space:pre">def GetBiomassInstand(standCompositionDict, standID, listOfSpecies):
    &quot;&quot;&quot;Retrieves the total biomass in a stand for a list of species.
    Returns a single biomass value.&quot;&quot;&quot;
    sumOfBiomass = 0
    for species in listOfSpecies:
        if species in standCompositionDict[standID]:
            sumOfBiomass += sum(standCompositionDict[standID][species].values())
    return(sumOfBiomass)</code></pre><button title="Copy to Clipboard" class="inline-flex items-center opacity-0 group-hover:opacity-100 hover:opacity-100 focus:opacity-100 active:opacity-100 cursor-pointer ml-2 transition-color duration-200 ease-in-out text-blue-400 hover:text-blue-500 absolute right-1 myst-code-copy-icon top-1" aria-pressed="false" aria-label="Copy code to clipboard"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" width="24" height="24"><path stroke-linecap="round" stroke-linejoin="round" d="M15.75 17.25v3.375c0 .621-.504 1.125-1.125 1.125h-9.75a1.125 1.125 0 0 1-1.125-1.125V7.875c0-.621.504-1.125 1.125-1.125H6.75a9.06 9.06 0 0 1 1.5.124m7.5 10.376h3.375c.621 0 1.125-.504 1.125-1.125V11.25c0-4.46-3.243-8.161-7.5-8.876a9.06 9.06 0 0 0-1.5-.124H9.375c-.621 0-1.125.504-1.125 1.125v3.5m7.5 10.375H9.375a1.125 1.125 0 0 1-1.125-1.125v-9.25m12 6.625v-1.875a3.375 3.375 0 0 0-3.375-3.375h-1.5a1.125 1.125 0 0 1-1.125-1.125v-1.5a3.375 3.375 0 0 0-3.375-3.375H9.75"></path></svg></button></div><ul><li>Reading the age of the stands (to see what stand are the oldest)</li></ul><div class="relative myst-code group not-prose my-5 text-sm shadow hover:shadow-md dark:shadow-2xl dark:shadow-neutral-900 bg-stone-200/10"><pre class="block overflow-auto p-3 myst-code-body hljs" style="background-color:unset"><code class="language-python" style="white-space:pre">def readingStandsAges(standMapPath, maxAgeMapsFolderPath, timestep, timestepLength, disableTQDM):
    &#x27;&#x27;&#x27;Uses the stand maps and max age map to compute the mean age of each stand
    (average of the age of the oldest cohorts in each pixels of the stand).
    Returns a dictionnary associating an age to a stand ID.
    The max age map is taken from the previous timestep to the current one.&#x27;&#x27;&#x27;
    print(&quot;Reading stands age...&quot;)
    
    standData = getRasterData(standMapPath)
    uniqueAllStandsID = np.unique(standData).tolist()
    # id 0 for stands = no forests
    uniqueAllStandsID.remove(0)
    cohortMaxAgeData = getRasterData(maxAgeMapsFolderPath + &quot;AGE-MAX-&quot; + str(timestep - timestepLength) + &quot;.img&quot;)
    maxAgeDict = dict()
    # Little trick to use the power of numpy below
    # We make an array with the pixels we want the value of, and another
    # with the values
    pixelCoordinates = np.where(standData != 0)
    standIDinPixelCoordinates = standData[pixelCoordinates]
    for standID in tqdm(uniqueAllStandsID, disable = disableTQDM):
        maxAgeDict[standID] = list()
    # We get the data for the harvestable pixels
    cohortMaxAgeInForestPixel = cohortMaxAgeData[pixelCoordinates]
    # We fill the dictionnary with the different values of max cohort age for each
    # pixels in a stand
    for i in tqdm(range(0, len(pixelCoordinates[0])), disable = disableTQDM):
        maxAgeDict[standIDinPixelCoordinates[i]].append(cohortMaxAgeInForestPixel[i])
    # We make a dictionnary containing the mean max age for each stand
    standAgeDict = dict()
    for standID in tqdm(uniqueAllStandsID, disable = disableTQDM):
        standAgeDict[standID] = statistics.mean(maxAgeDict[standID])
    return(standAgeDict)</code></pre><button title="Copy to Clipboard" class="inline-flex items-center opacity-0 group-hover:opacity-100 hover:opacity-100 focus:opacity-100 active:opacity-100 cursor-pointer ml-2 transition-color duration-200 ease-in-out text-blue-400 hover:text-blue-500 absolute right-1 myst-code-copy-icon top-1" aria-pressed="false" aria-label="Copy code to clipboard"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" width="24" height="24"><path stroke-linecap="round" stroke-linejoin="round" d="M15.75 17.25v3.375c0 .621-.504 1.125-1.125 1.125h-9.75a1.125 1.125 0 0 1-1.125-1.125V7.875c0-.621.504-1.125 1.125-1.125H6.75a9.06 9.06 0 0 1 1.5.124m7.5 10.376h3.375c.621 0 1.125-.504 1.125-1.125V11.25c0-4.46-3.243-8.161-7.5-8.876a9.06 9.06 0 0 0-1.5-.124H9.375c-.621 0-1.125.504-1.125 1.125v3.5m7.5 10.375H9.375a1.125 1.125 0 0 1-1.125-1.125v-9.25m12 6.625v-1.875a3.375 3.375 0 0 0-3.375-3.375h-1.5a1.125 1.125 0 0 1-1.125-1.125v-1.5a3.375 3.375 0 0 0-3.375-3.375H9.75"></path></svg></button></div><ul><li>Reading the management unit associated to each stand (remember that we are going to give non-sensical management area maps to B. Harvest if we want to control its behaviour, but we might still want to use management areas in our Python script to make our management decisions)</li></ul><div class="relative myst-code group not-prose my-5 text-sm shadow hover:shadow-md dark:shadow-2xl dark:shadow-neutral-900 bg-stone-200/10"><pre class="block overflow-auto p-3 myst-code-body hljs" style="background-color:unset"><code class="language-python" style="white-space:pre">def readingStandManagementUnit(standMapPath, managementUnitsMapPath, disableTQDM):
    &#x27;&#x27;&#x27;Assign a management unit (UA) code to each stand. This is not used to define
    management units per say in our landscape, but rather to get the conversion
    values from raw to net merchantable volume harvested, based on data from
    the ministry of forest (the data changes by species and by management unit).
    See coefficientRawToNetVolumes object for more info.&#x27;&#x27;&#x27;
    print(&quot;Reading stands management units (used for volume conversion)...&quot;)
    
    standData = getRasterData(standMapPath)
    uniqueAllStandsID = np.unique(standData).tolist()
    # id 0 for stands = no forests
    uniqueAllStandsID.remove(0)
    managementUnitsMap = getRasterData(managementUnitsMapPath)
    managementUnitDict = dict()
    # Little trick to use the power of numpy below
    # We make an array with the pixels we want the value of, and another
    # with the values
    pixelCoordinates = np.where(standData != 0)
    standIDinPixelCoordinates = standData[pixelCoordinates]
    for standID in tqdm(uniqueAllStandsID, disable = disableTQDM):
        managementUnitDict[standID] = list()
    # We get the data for the harvestable pixels
    managementUnitInPixel = managementUnitsMap[pixelCoordinates]
    # We fill the dictionnary with the different values of max cohort age for each
    # pixels in a stand
    for i in tqdm(range(0, len(pixelCoordinates[0])), disable = disableTQDM):
        managementUnitDict[standIDinPixelCoordinates[i]].append(managementUnitInPixel[i])
    # We make a dictionnary containing the mean max age for each stand
    standManagementUnitDict = dict()
    for standID in tqdm(uniqueAllStandsID, disable = disableTQDM):
        standManagementUnitDict[standID] = Counter(managementUnitDict[standID]).most_common(1)[0][0]
    return(standManagementUnitDict)</code></pre><button title="Copy to Clipboard" class="inline-flex items-center opacity-0 group-hover:opacity-100 hover:opacity-100 focus:opacity-100 active:opacity-100 cursor-pointer ml-2 transition-color duration-200 ease-in-out text-blue-400 hover:text-blue-500 absolute right-1 myst-code-copy-icon top-1" aria-pressed="false" aria-label="Copy code to clipboard"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" width="24" height="24"><path stroke-linecap="round" stroke-linejoin="round" d="M15.75 17.25v3.375c0 .621-.504 1.125-1.125 1.125h-9.75a1.125 1.125 0 0 1-1.125-1.125V7.875c0-.621.504-1.125 1.125-1.125H6.75a9.06 9.06 0 0 1 1.5.124m7.5 10.376h3.375c.621 0 1.125-.504 1.125-1.125V11.25c0-4.46-3.243-8.161-7.5-8.876a9.06 9.06 0 0 0-1.5-.124H9.375c-.621 0-1.125.504-1.125 1.125v3.5m7.5 10.375H9.375a1.125 1.125 0 0 1-1.125-1.125v-9.25m12 6.625v-1.875a3.375 3.375 0 0 0-3.375-3.375h-1.5a1.125 1.125 0 0 1-1.125-1.125v-1.5a3.375 3.375 0 0 0-3.375-3.375H9.75"></path></svg></button></div><ul><li>Writing in the raster map that we are going to create what pixels will be harvested with a given prescriptions</li></ul><div class="relative myst-code group not-prose my-5 text-sm shadow hover:shadow-md dark:shadow-2xl dark:shadow-neutral-900 bg-stone-200/10"><pre class="block overflow-auto p-3 myst-code-body hljs" style="background-color:unset"><code class="language-python" style="white-space:pre">def harvestStands(managementMap, standsList, standCoordinatesDict, prescriptionID):
    &quot;&quot;&quot;Edits the management map to indicate a list of stands as harvested with
    a given prescription ID. Returns the modified management map.&quot;&quot;&quot;
    numberOfPixelsHarvested = 0
    for standID in standsList:
        for pixel in standCoordinatesDict[standID]:
            managementMap[pixel] = prescriptionID
            numberOfPixelsHarvested += 1
    return(managementMap, numberOfPixelsHarvested)</code></pre><button title="Copy to Clipboard" class="inline-flex items-center opacity-0 group-hover:opacity-100 hover:opacity-100 focus:opacity-100 active:opacity-100 cursor-pointer ml-2 transition-color duration-200 ease-in-out text-blue-400 hover:text-blue-500 absolute right-1 myst-code-copy-icon top-1" aria-pressed="false" aria-label="Copy code to clipboard"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" width="24" height="24"><path stroke-linecap="round" stroke-linejoin="round" d="M15.75 17.25v3.375c0 .621-.504 1.125-1.125 1.125h-9.75a1.125 1.125 0 0 1-1.125-1.125V7.875c0-.621.504-1.125 1.125-1.125H6.75a9.06 9.06 0 0 1 1.5.124m7.5 10.376h3.375c.621 0 1.125-.504 1.125-1.125V11.25c0-4.46-3.243-8.161-7.5-8.876a9.06 9.06 0 0 0-1.5-.124H9.375c-.621 0-1.125.504-1.125 1.125v3.5m7.5 10.375H9.375a1.125 1.125 0 0 1-1.125-1.125v-9.25m12 6.625v-1.875a3.375 3.375 0 0 0-3.375-3.375h-1.5a1.125 1.125 0 0 1-1.125-1.125v-1.5a3.375 3.375 0 0 0-3.375-3.375H9.75"></path></svg></button></div><ul><li>A function to get what are the stands that are the neighbours of a stand if we want to propagate a cut accross several stand</li></ul><div class="relative myst-code group not-prose my-5 text-sm shadow hover:shadow-md dark:shadow-2xl dark:shadow-neutral-900 bg-stone-200/10"><pre class="block overflow-auto p-3 myst-code-body hljs" style="background-color:unset"><code class="language-python" style="white-space:pre">def readingStandsNeighbors(standRasterDataAll,
                           standCoordinatesDict,
                           disableTQDM = True):
    &#x27;&#x27;&#x27;Reads the neighbors of each stand by looking at the surrounding
    pixels of those of the stands, and getting their stand ID. Returns a dictionnary
    with the list of neighbors&#x27;s stand ID for each stand.&#x27;&#x27;&#x27;
    print(&quot;Reading stand neighbors...&quot;)
    
    # Making a dictionnary which tells what stand is a neighbor of which one.
    # We only need it for harvestable stands, since this is for the propagation
    # of cuts.
    standNeighboursDict = dict()
    minXRange = range(standRasterDataAll.shape[0])[0]
    maxXRange = range(standRasterDataAll.shape[0])[-1]
    minYRange = range(standRasterDataAll.shape[1])[0]
    maxYRange = range(standRasterDataAll.shape[1])[-1]
    for standID in tqdm(standCoordinatesDict.keys(), disable = disableTQDM):
        listOfNeighbouringStands = list()
        for pixel in standCoordinatesDict[standID]:
            listOfStandsAroundPixel = list()
            # We look at the 8 neighbors of the pixel, if not out of range,
            # to try to detect another stand number
            # First, we prepare the ranges around which we&#x27;ll loop, and make sure
            # we&#x27;re not out of bounds
            xMinus1 = max(pixel[0] - 1, minXRange)
            xPlus1 = min(pixel[0] + 1, maxXRange)
            yMinus1 = max(pixel[1] - 1, minYRange)
            yPlus1 = min(pixel[1] + 1, maxYRange)
            # Now, we loop to find values
            for x in [xMinus1, pixel[0], xPlus1]:
                for y in [yMinus1, pixel[1], yPlus1]:
                    listOfStandsAroundPixel.append(standRasterDataAll[(x, y)])
            uniqueNeighbouringStands = set(listOfStandsAroundPixel)
            # We remove mentions of the present stand and of the value 0
            uniqueNeighbouringStands.discard(standID)
            uniqueNeighbouringStands.discard(0)
            listOfNeighbouringStands.extend(list(uniqueNeighbouringStands))
        # We add the resulting unique standID that we found as neighbors to this stand
        standNeighboursDict[standID] = set(listOfNeighbouringStands)
    return(standNeighboursDict)</code></pre><button title="Copy to Clipboard" class="inline-flex items-center opacity-0 group-hover:opacity-100 hover:opacity-100 focus:opacity-100 active:opacity-100 cursor-pointer ml-2 transition-color duration-200 ease-in-out text-blue-400 hover:text-blue-500 absolute right-1 myst-code-copy-icon top-1" aria-pressed="false" aria-label="Copy code to clipboard"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" width="24" height="24"><path stroke-linecap="round" stroke-linejoin="round" d="M15.75 17.25v3.375c0 .621-.504 1.125-1.125 1.125h-9.75a1.125 1.125 0 0 1-1.125-1.125V7.875c0-.621.504-1.125 1.125-1.125H6.75a9.06 9.06 0 0 1 1.5.124m7.5 10.376h3.375c.621 0 1.125-.504 1.125-1.125V11.25c0-4.46-3.243-8.161-7.5-8.876a9.06 9.06 0 0 0-1.5-.124H9.375c-.621 0-1.125.504-1.125 1.125v3.5m7.5 10.375H9.375a1.125 1.125 0 0 1-1.125-1.125v-9.25m12 6.625v-1.875a3.375 3.375 0 0 0-3.375-3.375h-1.5a1.125 1.125 0 0 1-1.125-1.125v-1.5a3.375 3.375 0 0 0-3.375-3.375H9.75"></path></svg></button></div><ul><li>A function to propagate the cuts from stand to stand until we reach a certain size</li></ul><div class="relative myst-code group not-prose my-5 text-sm shadow hover:shadow-md dark:shadow-2xl dark:shadow-neutral-900 bg-stone-200/10"><pre class="block overflow-auto p-3 myst-code-body hljs" style="background-color:unset"><code class="language-python" style="white-space:pre">def standHarvestPropagation(standID,
                            prescription,
                            prescriptionParameters,
                            standNeighboursDict,
                            standCoordinatesDict,
                            standAgeDict):
    &quot;&quot;&quot;
    Propagate a harvest prescription from a stand to the neigbouring stands,
    depending on the selection criteria + min/max harvest size for the
    prescription.
    Returns a list of harvested stands.
    &quot;&quot;&quot;
    listOfHarvestedStands = list()
    frontier = [standID]
    surfaceHarvested = 0
    while surfaceHarvested &lt; prescriptionParameters[prescription][&quot;HarvestPropagation&quot;][1] and len(frontier) &gt; 0:
        focusStand = frontier.pop(0)
        # If we overeach the maximum surface, we stop here.
        if surfaceHarvested + len(standCoordinatesDict[focusStand]) &gt; prescriptionParameters[prescription][&quot;HarvestPropagation&quot;][1]:
            break
        else:
            listOfHarvestedStands.append(focusStand)
            # TO UPDATE : Surface harvested here is dealt in pixels. But in harvest parameter
            # file, might be in different units than pixel. See how to adapt to that. Need cell length ?
            surfaceHarvested += len(standCoordinatesDict[standID])
            for neighbor in standNeighboursDict[focusStand] :
                if neighbor not in listOfHarvestedStands and standAgeDict[neighbor] &gt; prescriptionParameters[prescription][&quot;MinimumStandAge&quot;] and standAgeDict[neighbor] &lt; prescriptionParameters[prescription][&quot;MaximumStandAge&quot;]:
                   frontier.append(neighbor) 
    return(listOfHarvestedStands)</code></pre><button title="Copy to Clipboard" class="inline-flex items-center opacity-0 group-hover:opacity-100 hover:opacity-100 focus:opacity-100 active:opacity-100 cursor-pointer ml-2 transition-color duration-200 ease-in-out text-blue-400 hover:text-blue-500 absolute right-1 myst-code-copy-icon top-1" aria-pressed="false" aria-label="Copy code to clipboard"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" width="24" height="24"><path stroke-linecap="round" stroke-linejoin="round" d="M15.75 17.25v3.375c0 .621-.504 1.125-1.125 1.125h-9.75a1.125 1.125 0 0 1-1.125-1.125V7.875c0-.621.504-1.125 1.125-1.125H6.75a9.06 9.06 0 0 1 1.5.124m7.5 10.376h3.375c.621 0 1.125-.504 1.125-1.125V11.25c0-4.46-3.243-8.161-7.5-8.876a9.06 9.06 0 0 0-1.5-.124H9.375c-.621 0-1.125.504-1.125 1.125v3.5m7.5 10.375H9.375a1.125 1.125 0 0 1-1.125-1.125v-9.25m12 6.625v-1.875a3.375 3.375 0 0 0-3.375-3.375h-1.5a1.125 1.125 0 0 1-1.125-1.125v-1.5a3.375 3.375 0 0 0-3.375-3.375H9.75"></path></svg></button></div><p>I won’t discuss all of the functions that are in the template, but there are a lot of them !</p><p>So as you see, the first section of this template contains a lot of functions. Many of them actually replace functions that are inside B. Harvest; reading the position of the stands, their age, etc. Again, the trade-off is that here, we have the freedom to do anything we want, but have to re-do it from A to Z. It’s like we’re writing an entire new model in our script. And that’s why these functions are here. The good news is : you won’t have to worry about them one bit ! They’re already ready. So a big, big chunk of the work is already done for you.</p><p>Another cool thing : <strong>it’s very easy to test these functions, to understand them or to create news ones</strong> ! Python is an intepreted langage like R, so you can run commands and interact with it easily. So, you can put your script in a folder containing LANDIS-II inputs and outputs, and you can try it out and see if it works line by line. This makes creating your algorithm and debugging it VASTLY easier than working in C#. In fact, you’ll see in the template a little section that allow you to run the script in “debug mode”.</p><div class="relative myst-code group not-prose my-5 text-sm shadow hover:shadow-md dark:shadow-2xl dark:shadow-neutral-900 bg-stone-200/10"><pre class="block overflow-auto p-3 myst-code-body hljs" style="background-color:unset"><code class="language-python" style="white-space:pre">#%% DEBUG

# Just put &quot;False&quot; unless you&#x27;re tinkering with this script.
debug = False
# debug = True

# If debugging, we prepare a dummy situation
if debug:
    os.chdir(r&quot;path/to/your/folder/with/simulation/files/landis-ii&quot;)
    timestep = 15
    BAU_Modifier = 1
    disableTQDM = False
    import matplotlib.pyplot as plt
else:
    # If not debugging, this Python script is normally called in a command prompt by specifying
    # some arguments, like the location of the folders containing the files that
    # we need relative to the LANDIS-II scenario file
    if __name__ == &quot;__main__&quot;:
        # Remember : argument at index 0 contains the program name.
        # The arguments that we want come after
        timestep = sys.argv[1]
        timestep = int(timestep)
        # You can retrieve other arguments here; just use sys.argv[2], sys.argv[3], etc. 
    # We disable the progress bars of TQDM to not display them in the LANDIS log
    disableTQDM = True</code></pre><button title="Copy to Clipboard" class="inline-flex items-center opacity-0 group-hover:opacity-100 hover:opacity-100 focus:opacity-100 active:opacity-100 cursor-pointer ml-2 transition-color duration-200 ease-in-out text-blue-400 hover:text-blue-500 absolute right-1 myst-code-copy-icon top-1" aria-pressed="false" aria-label="Copy code to clipboard"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" width="24" height="24"><path stroke-linecap="round" stroke-linejoin="round" d="M15.75 17.25v3.375c0 .621-.504 1.125-1.125 1.125h-9.75a1.125 1.125 0 0 1-1.125-1.125V7.875c0-.621.504-1.125 1.125-1.125H6.75a9.06 9.06 0 0 1 1.5.124m7.5 10.376h3.375c.621 0 1.125-.504 1.125-1.125V11.25c0-4.46-3.243-8.161-7.5-8.876a9.06 9.06 0 0 0-1.5-.124H9.375c-.621 0-1.125.504-1.125 1.125v3.5m7.5 10.375H9.375a1.125 1.125 0 0 1-1.125-1.125v-9.25m12 6.625v-1.875a3.375 3.375 0 0 0-3.375-3.375h-1.5a1.125 1.125 0 0 1-1.125-1.125v-1.5a3.375 3.375 0 0 0-3.375-3.375H9.75"></path></svg></button></div><p>If not in debug mode, you’ll see (see code snippet above) that the script will attempt to gather “arguments” that were given with the command; here, I’m taking the <code>{timestep}</code> argument i’ve passed through the Magic Harvest Parameter text file from earlier (which Magic Harvest will transform into the LANDIS-II time step at which the script is launched). This way, I have a variable in my script that contains the current time step. There are other ways to get the current time step - for example, by looking at LANDIS-II output files - but this one is the simplest and most reliable in my opinion.</p><h3 id="using-functions-to-read-the-state-of-the-landscape" class="relative group"><span class="heading-text">Using functions to read the state of the landscape</span><a class="no-underline text-inherit hover:text-inherit inline-block w-0 px-0 translate-x-[10px] font-normal select-none transition-opacity opacity-0 focus:opacity-100 group-hover:opacity-70" href="#using-functions-to-read-the-state-of-the-landscape" title="Link to this Section" aria-label="Link to this Section">¶</a></h3><p>The second section of the script is then using the functions we’ve just looked at to read files and load the informations of the landscape into Python variables, especially Python dictionnaries.</p><div class="relative myst-code group not-prose my-5 text-sm shadow hover:shadow-md dark:shadow-2xl dark:shadow-neutral-900 bg-stone-200/10"><pre class="block overflow-auto p-3 myst-code-body hljs" style="background-color:unset"><code class="language-python" style="white-space:pre">#%% DEFINING PARAMETERS FOR EACH PRESCRIPTION

# We read the template harvest parameter file, which also contains the parameters needed
# for magic harvest
prescriptionParameters, timestepLength = harvestParameterFileParser(&quot;./input/disturbances/harvesting/harvest_BAU_v2.0_TEMPLATE.txt&quot;)

#%% READING DATA FOR TIME STEP

# Reading files for stand coordinates
standRasterData = getRasterData(&quot;../../sharedRasters/stands_v2.0.tif&quot;)
standCoordinatesDict = readingStandsCoordinates(standRasterData,
                                                disableTQDM)

# Reading raster of Management units (UAs)
standUADict = readingStandManagementUnit(&quot;../../sharedRasters/stands_v2.0.tif&quot;,
                                         &quot;../../sharedRasters/rasterUAInterpolated.tif&quot;,
                                         disableTQDM)

# Reading JSON files for repeated prescriptions
repeatPrescriptionPath = &quot;./input/disturbances/harvesting/temp/repeatedPrescriptions.pickle&quot;
if os.path.exists(&quot;repeatPrescriptionPath&quot;):
    with open(repeatPrescriptionPath) as repeatedPrescriptionFile:
        pickle.load(repeatPrescriptionsDict, repeatedPrescriptionFile)
else:
    repeatPrescriptionsDict = &quot;noRepeatsForNow&quot;

# Reading vegetation communities
standCompositionDict = readCommunitiesComplete(&quot;./community-input-file-&quot; + str(timestep- timestepLength) + &quot;.csv&quot;,
                                            &quot;./output-community-&quot; + str(timestep- timestepLength) + &quot;.img&quot;,
                                            standCoordinatesDict,
                                            disableTQDM)

# Reading stand ages
standAgeDict = readingStandsAges(&quot;../../sharedRasters/stands_v2.0.tif&quot;,
                         &quot;./output/cohort-stats/&quot;,
                         timestep,
                         timestepLength,
                         disableTQDM)

# Determining forest types
forestTypesStandsDict = DetermineForestTypesOfStands(standCompositionDict,
                                                     standCoordinatesDict,
                                                     disableTQDM)

# Determining management unit for each stand (used for the conversion of
# raw to net merchantable volume harvested)

# stand neighbors dict (used for stand propagation)
standNeighboursDict = readingStandsNeighbors(standRasterData,
                                            standCoordinatesDict,
                                            disableTQDM)</code></pre><button title="Copy to Clipboard" class="inline-flex items-center opacity-0 group-hover:opacity-100 hover:opacity-100 focus:opacity-100 active:opacity-100 cursor-pointer ml-2 transition-color duration-200 ease-in-out text-blue-400 hover:text-blue-500 absolute right-1 myst-code-copy-icon top-1" aria-pressed="false" aria-label="Copy code to clipboard"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" width="24" height="24"><path stroke-linecap="round" stroke-linejoin="round" d="M15.75 17.25v3.375c0 .621-.504 1.125-1.125 1.125h-9.75a1.125 1.125 0 0 1-1.125-1.125V7.875c0-.621.504-1.125 1.125-1.125H6.75a9.06 9.06 0 0 1 1.5.124m7.5 10.376h3.375c.621 0 1.125-.504 1.125-1.125V11.25c0-4.46-3.243-8.161-7.5-8.876a9.06 9.06 0 0 0-1.5-.124H9.375c-.621 0-1.125.504-1.125 1.125v3.5m7.5 10.375H9.375a1.125 1.125 0 0 1-1.125-1.125v-9.25m12 6.625v-1.875a3.375 3.375 0 0 0-3.375-3.375h-1.5a1.125 1.125 0 0 1-1.125-1.125v-1.5a3.375 3.375 0 0 0-3.375-3.375H9.75"></path></svg></button></div><p>You might notice that one of these parts deals with repeated prescriptions. So in B. Harvest, you can have prescription that will periodically come back to a given stand - like long-term uneven-aged management or partial cuts -, or come from a second final cut - like the shelterwood method. Again, B. Harvest deals with all through the internal variables of LANDIS-II, in the RAM of the computer. However, <strong>the Python script that we run at every time step with Magic Harvest doesn’t have a permanent memory</strong>; when the script will finish for a given timestep, it will unload its variables. So, if you want to keep information saved for your script to re-load it at the next time step - for example, the list of stands that have repeated prescriptions so that you know which one to re-harvest periodically in the future - , <strong>you’ll have to save this in a file</strong>.</p><p>Python makes that easy, with many choices : you can export Python objects - like Python dictionnaries - into a .json file, which is a popular format that is human-readable - meaning that you can open the file and read it yourself. You can also save it in “Pickle” format, which is not human readable, but which is made to save and load python objects easily. I recommand the pickle format for complex objects, and the Json format for simpler ones.</p><p>Here is the code used later in the script (in the section where outputs are done) :</p><div class="relative myst-code group not-prose my-5 text-sm shadow hover:shadow-md dark:shadow-2xl dark:shadow-neutral-900 bg-stone-200/10"><pre class="block overflow-auto p-3 myst-code-body hljs" style="background-color:unset"><code class="language-python" style="white-space:pre"># We save the pickle file with the data for the next repeated harvests
# Wanted to use JSON, but doesn&#x27;t work well with the complex dictionnaries I use.
# WARNING : pickle is not human-readable. It is made to be read by a Python script.
if repeatPrescriptionsDict!= &quot;noRepeatsForNow&quot;:
    with open(&#x27;./input/disturbances/harvesting/tempMagicHarvest/repeatedPrescriptions.pickle&#x27;, &quot;wb+&quot;) as outfile:
        pickle.dump(repeatPrescriptionsDict, outfile)</code></pre><button title="Copy to Clipboard" class="inline-flex items-center opacity-0 group-hover:opacity-100 hover:opacity-100 focus:opacity-100 active:opacity-100 cursor-pointer ml-2 transition-color duration-200 ease-in-out text-blue-400 hover:text-blue-500 absolute right-1 myst-code-copy-icon top-1" aria-pressed="false" aria-label="Copy code to clipboard"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" width="24" height="24"><path stroke-linecap="round" stroke-linejoin="round" d="M15.75 17.25v3.375c0 .621-.504 1.125-1.125 1.125h-9.75a1.125 1.125 0 0 1-1.125-1.125V7.875c0-.621.504-1.125 1.125-1.125H6.75a9.06 9.06 0 0 1 1.5.124m7.5 10.376h3.375c.621 0 1.125-.504 1.125-1.125V11.25c0-4.46-3.243-8.161-7.5-8.876a9.06 9.06 0 0 0-1.5-.124H9.375c-.621 0-1.125.504-1.125 1.125v3.5m7.5 10.375H9.375a1.125 1.125 0 0 1-1.125-1.125v-9.25m12 6.625v-1.875a3.375 3.375 0 0 0-3.375-3.375h-1.5a1.125 1.125 0 0 1-1.125-1.125v-1.5a3.375 3.375 0 0 0-3.375-3.375H9.75"></path></svg></button></div><p>You can see that there are also a couple of lines to remove the files made by the Biomass Community extension, and which contain all of the vegetation data at the end of the previous timestep (and so, if Magic Harvest is the first disturbance extension to run, it’s also the state of the current time step before anything happens). These files are very heavy, so you might want to remove them once you’re done reading them.</p><div class="relative myst-code group not-prose my-5 text-sm shadow hover:shadow-md dark:shadow-2xl dark:shadow-neutral-900 bg-stone-200/10"><pre class="block overflow-auto p-3 myst-code-body hljs" style="background-color:unset"><code class="language-python" style="white-space:pre"># Removing vegetation communities files if needed
if not debug and removeCommunitiesFiles:
    if os.path.exists(&quot;./output-community-&quot; + str(timestep- timestepLength) + &quot;.img&quot;):
        os.remove(&quot;./output-community-&quot; + str(timestep- timestepLength) + &quot;.img&quot;)
    if os.path.exists(&quot;./community-input-file-&quot; + str(timestep- timestepLength) + &quot;.csv&quot;):
        os.remove(&quot;./community-input-file-&quot; + str(timestep- timestepLength) + &quot;.csv&quot;)
    if os.path.exists((&quot;./community-input-file-&quot; + str(timestep- timestepLength) + &quot;.csv&quot;)[0:-3] + &quot;txt&quot;):
        os.remove((&quot;./community-input-file-&quot; + str(timestep- timestepLength) + &quot;.csv&quot;)[0:-3] + &quot;txt&quot;)</code></pre><button title="Copy to Clipboard" class="inline-flex items-center opacity-0 group-hover:opacity-100 hover:opacity-100 focus:opacity-100 active:opacity-100 cursor-pointer ml-2 transition-color duration-200 ease-in-out text-blue-400 hover:text-blue-500 absolute right-1 myst-code-copy-icon top-1" aria-pressed="false" aria-label="Copy code to clipboard"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" width="24" height="24"><path stroke-linecap="round" stroke-linejoin="round" d="M15.75 17.25v3.375c0 .621-.504 1.125-1.125 1.125h-9.75a1.125 1.125 0 0 1-1.125-1.125V7.875c0-.621.504-1.125 1.125-1.125H6.75a9.06 9.06 0 0 1 1.5.124m7.5 10.376h3.375c.621 0 1.125-.504 1.125-1.125V11.25c0-4.46-3.243-8.161-7.5-8.876a9.06 9.06 0 0 0-1.5-.124H9.375c-.621 0-1.125.504-1.125 1.125v3.5m7.5 10.375H9.375a1.125 1.125 0 0 1-1.125-1.125v-9.25m12 6.625v-1.875a3.375 3.375 0 0 0-3.375-3.375h-1.5a1.125 1.125 0 0 1-1.125-1.125v-1.5a3.375 3.375 0 0 0-3.375-3.375H9.75"></path></svg></button></div><p>You can also see that there is a line preparing a two dimensional numpy array with the same dimensions as the management area map, but filled with zeroes. This is the array we will fill with the location of the pixels we want to harvest precisely, and that we will use to create the management raster that we will feedback to B. Harvest to control its harvesting, as I explained before.</p><div class="relative myst-code group not-prose my-5 text-sm shadow hover:shadow-md dark:shadow-2xl dark:shadow-neutral-900 bg-stone-200/10"><pre class="block overflow-auto p-3 myst-code-body hljs" style="background-color:unset"><code class="language-python" style="white-space:pre">#%% PREPARING OTHER OBJECTS WE NEED

# We prepare the empty management map that we will fill with the values of the pixels where we want to harvest.
managementMap = np.zeros_like(getRasterData(&quot;../../sharedRasters/stands_v2.0.tif&quot;))</code></pre><button title="Copy to Clipboard" class="inline-flex items-center opacity-0 group-hover:opacity-100 hover:opacity-100 focus:opacity-100 active:opacity-100 cursor-pointer ml-2 transition-color duration-200 ease-in-out text-blue-400 hover:text-blue-500 absolute right-1 myst-code-copy-icon top-1" aria-pressed="false" aria-label="Copy code to clipboard"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" width="24" height="24"><path stroke-linecap="round" stroke-linejoin="round" d="M15.75 17.25v3.375c0 .621-.504 1.125-1.125 1.125h-9.75a1.125 1.125 0 0 1-1.125-1.125V7.875c0-.621.504-1.125 1.125-1.125H6.75a9.06 9.06 0 0 1 1.5.124m7.5 10.376h3.375c.621 0 1.125-.504 1.125-1.125V11.25c0-4.46-3.243-8.161-7.5-8.876a9.06 9.06 0 0 0-1.5-.124H9.375c-.621 0-1.125.504-1.125 1.125v3.5m7.5 10.375H9.375a1.125 1.125 0 0 1-1.125-1.125v-9.25m12 6.625v-1.875a3.375 3.375 0 0 0-3.375-3.375h-1.5a1.125 1.125 0 0 1-1.125-1.125v-1.5a3.375 3.375 0 0 0-3.375-3.375H9.75"></path></svg></button></div><h3 id="making-the-management-decisions" class="relative group"><span class="heading-text">Making the management decisions</span><a class="no-underline text-inherit hover:text-inherit inline-block w-0 px-0 translate-x-[10px] font-normal select-none transition-opacity opacity-0 focus:opacity-100 group-hover:opacity-70" href="#making-the-management-decisions" title="Link to this Section" aria-label="Link to this Section">¶</a></h3><p>Now that everything is loaded, this is the part where you can do your management decisions. Here, as this script is a template, this part is empty. We’re going to do some exercises together afterward to explore what we can do here. But sky’s the limit. The only thing we have to do is to fill the array that will be used to output our management map, where each pixel contains the code of the prescription we want to apply in this pixel. The rest is up to our imagination.</p><div class="relative myst-code group not-prose my-5 text-sm shadow hover:shadow-md dark:shadow-2xl dark:shadow-neutral-900 bg-stone-200/10"><pre class="block overflow-auto p-3 myst-code-body hljs" style="background-color:unset"><code class="language-python" style="white-space:pre">#%% MAKING THE HARVEST DECISIONS

# This is where you should write functions that will define where you want to harvest.
# So, doing your repeated prescriptions, ranking the stands and then applying new prescriptions until you 
# reach a given target, etc., etc.
</code></pre><button title="Copy to Clipboard" class="inline-flex items-center opacity-0 group-hover:opacity-100 hover:opacity-100 focus:opacity-100 active:opacity-100 cursor-pointer ml-2 transition-color duration-200 ease-in-out text-blue-400 hover:text-blue-500 absolute right-1 myst-code-copy-icon top-1" aria-pressed="false" aria-label="Copy code to clipboard"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" width="24" height="24"><path stroke-linecap="round" stroke-linejoin="round" d="M15.75 17.25v3.375c0 .621-.504 1.125-1.125 1.125h-9.75a1.125 1.125 0 0 1-1.125-1.125V7.875c0-.621.504-1.125 1.125-1.125H6.75a9.06 9.06 0 0 1 1.5.124m7.5 10.376h3.375c.621 0 1.125-.504 1.125-1.125V11.25c0-4.46-3.243-8.161-7.5-8.876a9.06 9.06 0 0 0-1.5-.124H9.375c-.621 0-1.125.504-1.125 1.125v3.5m7.5 10.375H9.375a1.125 1.125 0 0 1-1.125-1.125v-9.25m12 6.625v-1.875a3.375 3.375 0 0 0-3.375-3.375h-1.5a1.125 1.125 0 0 1-1.125-1.125v-1.5a3.375 3.375 0 0 0-3.375-3.375H9.75"></path></svg></button></div><h3 id="creating-the-outputs-to-control-biomass-harvest-and-others" class="relative group"><span class="heading-text">Creating the outputs to control Biomass Harvest and others</span><a class="no-underline text-inherit hover:text-inherit inline-block w-0 px-0 translate-x-[10px] font-normal select-none transition-opacity opacity-0 focus:opacity-100 group-hover:opacity-70" href="#creating-the-outputs-to-control-biomass-harvest-and-others" title="Link to this Section" aria-label="Link to this Section">¶</a></h3><p>The final section is simply the creation of the outputs. We create an object containing information about the repeated prescription for the next; we create the raster map to give to B. Harvest to control its harvesting using the array we filled before; and we then edit the parameter text file of B. Harvest to add new prescriptions if we want to, indicate the name of this new management map we’re giving him, and also to write the implementation table to force him to harvest 100% of each pixel codes we have put in the map, as I’ve described before. The template also writes a couple of log files to help reading what happenned after the simulation.</p><div class="relative myst-code group not-prose my-5 text-sm shadow hover:shadow-md dark:shadow-2xl dark:shadow-neutral-900 bg-stone-200/10"><pre class="block overflow-auto p-3 myst-code-body hljs" style="background-color:unset"><code class="language-python" style="white-space:pre">#%% OUTPUTS

# This is where we create the files that we will give back to Biomass Harvest

print(&quot;Creating outputs...&quot;)

# We prepare the folder with temporary files
if not os.path.exists(&quot;./input/disturbances/harvesting/tempMagicHarvest/&quot;):
    os.mkdir(&quot;./input/disturbances/harvesting/tempMagicHarvest/&quot;)

# We save the pickle file with the data for the next repeated harvests
# Wanted to use JSON, but doesn&#x27;t work well with the complex dictionnaries I use.
# WARNING : pickle is not human-readable. It is made to be read by a Python script.
if repeatPrescriptionsDict!= &quot;noRepeatsForNow&quot;:
    with open(&#x27;./input/disturbances/harvesting/tempMagicHarvest/repeatedPrescriptions.pickle&#x27;, &quot;wb+&quot;) as outfile:
        pickle.dump(repeatPrescriptionsDict, outfile)

# Create harvest maps
print(&quot;Magic harvest Python script : WRITING PRESCRIPTION MAP&quot;)
writeNewRasterData(managementMap,
                    &quot;../../sharedRasters/stands_v2.0.tif&quot;,
                    &quot;./input/disturbances/harvesting/tempMagicHarvest/prescriptions-&quot; + str(timestep) + &quot;.tif&quot;)

# Create harvest txt file
# We add to the txt file :
# - The new plantation prescriptions
# - The surface to harvest for each prescription ID / fake management areas to contrain harvesting
writeHarvestParameterFile(managementMap,
                            &quot;/input/disturbances/harvesting/&quot;,
                            &quot;harvest_BAU_v2.0_TEMPLATE.txt&quot;,
                            &quot;harvest_BAU_v2.0.txt&quot;,
                            prescriptionParameters,
                            &quot;./input/disturbances/harvesting/tempMagicHarvest/prescriptions-&quot; + str(timestep) + &quot;.tif&quot;,
                            timestep)

# Update table that gives the prescription names for each prescription ID
# for easy identification in GIS softwares of the harvest output maps
WriteTableOfPrescriptionsID(&quot;./input/disturbances/harvesting/tempMagicHarvest/prescriptionIDTable-&quot; + str(timestep) + &quot;.csv&quot;,
                            prescriptionParameters)

# We make a log of the harvested surfaces and volumes.
csvFileOutputPath = &quot;./output/magicHarvest/logMagicHarvest.csv&quot;


# If first timestep, we create the file.
if timestep == timestepLength:
    if os.path.exists(csvFileOutputPath):
        os.remove(csvFileOutputPath)
    
    # We make the output directories if they don&#x27;t already exist
    if not os.path.exists(os.path.dirname(csvFileOutputPath)):
        os.makedirs(os.path.dirname(csvFileOutputPath))
        
    listOfHeaders = [&quot;Timestep&quot;, &quot;Surface Harvested&quot;]
    for target in volumeTargetDicts:
        listOfHeaders.append(&quot;Volume &quot; + str(target) + &quot; harvested&quot;)
    
    with open(csvFileOutputPath, &#x27;w+&#x27;, newline=&#x27;&#x27;) as file:
        writer = csv.writer(file)
        writer.writerow(listOfHeaders)

# Then, we write the values
newRow = [str(timestep), str(np.count_nonzero(managementMap))]
for target in volumeTargetDicts:
    newRow.append(str(volumeTargetCounterDict[target]))
with open(csvFileOutputPath, &#x27;a&#x27;, newline=&#x27;&#x27;) as file:
    writer = csv.writer(file)
    writer.writerow(newRow)</code></pre><button title="Copy to Clipboard" class="inline-flex items-center opacity-0 group-hover:opacity-100 hover:opacity-100 focus:opacity-100 active:opacity-100 cursor-pointer ml-2 transition-color duration-200 ease-in-out text-blue-400 hover:text-blue-500 absolute right-1 myst-code-copy-icon top-1" aria-pressed="false" aria-label="Copy code to clipboard"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" width="24" height="24"><path stroke-linecap="round" stroke-linejoin="round" d="M15.75 17.25v3.375c0 .621-.504 1.125-1.125 1.125h-9.75a1.125 1.125 0 0 1-1.125-1.125V7.875c0-.621.504-1.125 1.125-1.125H6.75a9.06 9.06 0 0 1 1.5.124m7.5 10.376h3.375c.621 0 1.125-.504 1.125-1.125V11.25c0-4.46-3.243-8.161-7.5-8.876a9.06 9.06 0 0 0-1.5-.124H9.375c-.621 0-1.125.504-1.125 1.125v3.5m7.5 10.375H9.375a1.125 1.125 0 0 1-1.125-1.125v-9.25m12 6.625v-1.875a3.375 3.375 0 0 0-3.375-3.375h-1.5a1.125 1.125 0 0 1-1.125-1.125v-1.5a3.375 3.375 0 0 0-3.375-3.375H9.75"></path></svg></button></div><p>And that’s it ! Once the script is over, Magic Harvest will force B. Harvest to re-load its parameters, and B. Harvest will then activate and harvest the pixels in the way we told him.</p><p>Of course, there are many functions that you could add to the template; for example, functions to read the rasters from other disturbances extensions (like fire and insect epidemics) to then know where to do salvage logging. Don’t feel restricted by what I’ve described here. In fact, we’re now going to finish by making you use your imagination a bit !</p><h2 id="conclusion-about-using-magic-harvest-in-practice" class="relative group"><span class="heading-text">Conclusion about using Magic Harvest in practice</span><a class="no-underline text-inherit hover:text-inherit inline-block w-0 px-0 translate-x-[10px] font-normal select-none transition-opacity opacity-0 focus:opacity-100 group-hover:opacity-70" href="#conclusion-about-using-magic-harvest-in-practice" title="Link to this Section" aria-label="Link to this Section">¶</a></h2><p>You should now have a pretty good idea of how using Magic Harvest works in term of using files; or at least inspiration to do your own script and run them in LANDIS-II.</p><p>We’re going to finish by doing a couple of exercises to train your imagination to write some algorithms to make your management decisions through a script.</p><div></div><div class="flex pt-10 mb-10 space-x-4"><a class="flex-1 block p-4 font-normal text-gray-600 no-underline border border-gray-200 rounded shadow-sm group hover:border-blue-600 dark:hover:border-blue-400 hover:text-blue-600 dark:hover:text-blue-400 dark:text-gray-100 dark:border-gray-500 hover:shadow-lg dark:shadow-neutral-700" href="https://klemet.github.io/Workshop-MagicHarvest/howmagicharvestworks"><div class="flex h-full align-middle"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" width="1.5rem" height="1.5rem" class="self-center transition-transform group-hover:-translate-x-1 shrink-0"><path stroke-linecap="round" stroke-linejoin="round" d="M10.5 19.5 3 12m0 0 7.5-7.5M3 12h18"></path></svg><div class="flex-grow text-right"><div class="text-xs text-gray-500 dark:text-gray-400">Introduction</div>How Magic Harvest Works</div></div></a><a class="flex-1 block p-4 font-normal text-gray-600 no-underline border border-gray-200 rounded shadow-sm group hover:border-blue-600 dark:hover:border-blue-400 hover:text-blue-600 dark:hover:text-blue-400 dark:text-gray-100 dark:border-gray-500 hover:shadow-lg dark:shadow-neutral-700" href="https://klemet.github.io/Workshop-MagicHarvest/exercises"><div class="flex h-full align-middle"><div class="flex-grow"><div class="text-xs text-gray-500 dark:text-gray-400">Introduction</div>Exercices</div><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" width="1.5rem" height="1.5rem" class="self-center transition-transform group-hover:translate-x-1 shrink-0"><path stroke-linecap="round" stroke-linejoin="round" d="M13.5 4.5 21 12m0 0-7.5 7.5M21 12H3"></path></svg></div></a></div></main></article><script>((a,d)=>{if(!window.history.state||!window.history.state.key){let h=Math.random().toString(32).slice(2);window.history.replaceState({key:h},"")}try{let f=JSON.parse(sessionStorage.getItem(a)||"{}")[d||window.history.state.key];typeof f=="number"&&window.scrollTo(0,f)}catch(h){console.error(h),sessionStorage.removeItem(a)}})("positions", null)</script><link rel="modulepreload" href="https://klemet.github.io/Workshop-MagicHarvest/build/entry.client-UNPC4GT3.js"/><link rel="modulepreload" href="https://klemet.github.io/Workshop-MagicHarvest/build/_shared/chunk-OCTKKCIL.js"/><link rel="modulepreload" href="https://klemet.github.io/Workshop-MagicHarvest/build/_shared/chunk-UAI5KRM7.js"/><link rel="modulepreload" href="https://klemet.github.io/Workshop-MagicHarvest/build/_shared/chunk-2NH4LW52.js"/><link rel="modulepreload" href="https://klemet.github.io/Workshop-MagicHarvest/build/_shared/chunk-JSE36H2O.js"/><link rel="modulepreload" href="https://klemet.github.io/Workshop-MagicHarvest/build/_shared/chunk-HBJK6BW3.js"/><link rel="modulepreload" href="https://klemet.github.io/Workshop-MagicHarvest/build/_shared/chunk-HYMQ7M2K.js"/><link rel="modulepreload" href="https://klemet.github.io/Workshop-MagicHarvest/build/_shared/chunk-OHOXABTA.js"/><link rel="modulepreload" href="https://klemet.github.io/Workshop-MagicHarvest/build/_shared/chunk-OCWQY3HK.js"/><link rel="modulepreload" href="https://klemet.github.io/Workshop-MagicHarvest/build/_shared/chunk-C7FW3E47.js"/><link rel="modulepreload" href="https://klemet.github.io/Workshop-MagicHarvest/build/_shared/chunk-3CVK3PYF.js"/><link rel="modulepreload" href="https://klemet.github.io/Workshop-MagicHarvest/build/_shared/chunk-J6FHCSRC.js"/><link rel="modulepreload" href="https://klemet.github.io/Workshop-MagicHarvest/build/_shared/chunk-ND43KHSX.js"/><link rel="modulepreload" href="https://klemet.github.io/Workshop-MagicHarvest/build/_shared/chunk-GUCIBHGO.js"/><link rel="modulepreload" href="https://klemet.github.io/Workshop-MagicHarvest/build/root-IB5726YR.js"/><link rel="modulepreload" href="https://klemet.github.io/Workshop-MagicHarvest/build/_shared/chunk-NBON2RSI.js"/><link rel="modulepreload" href="https://klemet.github.io/Workshop-MagicHarvest/build/routes/$-LXLHKVOR.js"/><script>window.__remixContext = {"url":"/lookingatthingsinpractice","state":{"loaderData":{"root":{"config":{"version":2,"myst":"1.6.0","options":{},"nav":[],"actions":[],"projects":[{"id":"a9d9bd1a-fce3-4a75-94db-95be0178f5ce","thumbnail":"https://klemet.github.io/Workshop-MagicHarvest/build/c46244155f82f0a2188b900fb12670c3.svg","exports":[],"bibliography":[],"title":"Introduction","index":"introduction","pages":[{"slug":"howmagicharvestworks","title":"How Magic Harvest Works","description":"","date":"","thumbnail":"https://klemet.github.io/Workshop-MagicHarvest/build/c46244155f82f0a2188b900fb12670c3.svg","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":1},{"slug":"lookingatthingsinpractice","title":"Using Magic Harvest in practice","description":"","date":"","thumbnail":"https://klemet.github.io/Workshop-MagicHarvest/build/c46244155f82f0a2188b900fb12670c3.svg","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":1},{"slug":"exercises","title":"Exercices","description":"","date":"","thumbnail":"https://klemet.github.io/Workshop-MagicHarvest/build/c46244155f82f0a2188b900fb12670c3.svg","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":1},{"slug":"conclusion","title":"Conclusion","description":"","date":"","thumbnail":"https://klemet.github.io/Workshop-MagicHarvest/build/c46244155f82f0a2188b900fb12670c3.svg","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":1}]}]},"CONTENT_CDN_PORT":"3101","MODE":"static","BASE_URL":"https://klemet.github.io/Workshop-MagicHarvest"},"routes/$":{"config":{"version":2,"myst":"1.6.0","options":{},"nav":[],"actions":[],"projects":[{"id":"a9d9bd1a-fce3-4a75-94db-95be0178f5ce","thumbnail":"https://klemet.github.io/Workshop-MagicHarvest/build/c46244155f82f0a2188b900fb12670c3.svg","exports":[],"bibliography":[],"title":"Introduction","index":"introduction","pages":[{"slug":"howmagicharvestworks","title":"How Magic Harvest Works","description":"","date":"","thumbnail":"https://klemet.github.io/Workshop-MagicHarvest/build/c46244155f82f0a2188b900fb12670c3.svg","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":1},{"slug":"lookingatthingsinpractice","title":"Using Magic Harvest in practice","description":"","date":"","thumbnail":"https://klemet.github.io/Workshop-MagicHarvest/build/c46244155f82f0a2188b900fb12670c3.svg","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":1},{"slug":"exercises","title":"Exercices","description":"","date":"","thumbnail":"https://klemet.github.io/Workshop-MagicHarvest/build/c46244155f82f0a2188b900fb12670c3.svg","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":1},{"slug":"conclusion","title":"Conclusion","description":"","date":"","thumbnail":"https://klemet.github.io/Workshop-MagicHarvest/build/c46244155f82f0a2188b900fb12670c3.svg","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":1}]}]},"page":{"version":2,"kind":"Article","sha256":"8867221fd58f2eed5eb4d5e811067794bab17fdb44f40c5543917c7d70cb43b3","slug":"lookingatthingsinpractice","location":"/02-LookingAtThingsInPractice.md","dependencies":[],"frontmatter":{"title":"Using Magic Harvest in practice","content_includes_title":false,"thumbnail":"https://klemet.github.io/Workshop-MagicHarvest/build/c46244155f82f0a2188b900fb12670c3.svg","exports":[{"format":"md","filename":"02-LookingAtThingsInPractice.md","url":"https://klemet.github.io/Workshop-MagicHarvest/build/02-LookingAtThingsIn-59145e240b33789fb3984ee8d4930895.md"}]},"mdast":{"type":"root","children":[{"type":"block","children":[{"type":"paragraph","position":{"start":{"line":2,"column":1},"end":{"line":3,"column":1}},"children":[{"type":"strong","position":{"start":{"line":2,"column":1},"end":{"line":2,"column":1}},"children":[{"type":"text","value":"Authors:","position":{"start":{"line":2,"column":1},"end":{"line":2,"column":1}},"key":"wilJf3QVy9"}],"key":"zNR5AZOQd0"},{"type":"text","value":" Clément Hardy","position":{"start":{"line":2,"column":1},"end":{"line":2,"column":1}},"key":"J1xcmghMqb"},{"type":"superscript","children":[{"type":"text","value":"1","key":"sJBYSDry7r"}],"key":"ZEMyhzrl59"},{"type":"text","value":" ","position":{"start":{"line":2,"column":1},"end":{"line":2,"column":1}},"key":"nLVNHQnlc0"},{"type":"break","position":{"start":{"line":2,"column":1},"end":{"line":2,"column":1}},"key":"YForxXxJ6f"},{"type":"strong","position":{"start":{"line":2,"column":1},"end":{"line":2,"column":1}},"children":[{"type":"text","value":"Affiliations:","position":{"start":{"line":2,"column":1},"end":{"line":2,"column":1}},"key":"p7fZWliyz1"}],"key":"Ox5qRVBHsb"},{"type":"text","value":" ","position":{"start":{"line":2,"column":1},"end":{"line":2,"column":1}},"key":"d0EQY0upDE"},{"type":"superscript","children":[{"type":"text","value":"1","key":"lVaYRN6U6z"}],"key":"MHn7fx4CT0"},{"type":"text","value":"Université du Québec en Outaouais (UQO)\\","position":{"start":{"line":2,"column":1},"end":{"line":2,"column":1}},"key":"MIyeevGkDy"}],"key":"OQEFlJSL3n"},{"type":"paragraph","position":{"start":{"line":5,"column":1},"end":{"line":5,"column":1}},"children":[{"type":"link","url":"https://myst.tools","position":{"start":{"line":5,"column":1},"end":{"line":5,"column":1}},"children":[{"type":"image","url":"https://klemet.github.io/Workshop-MagicHarvest/build/c46244155f82f0a2188b900fb12670c3.svg","alt":"Made with MyST","position":{"start":{"line":5,"column":1},"end":{"line":5,"column":1}},"key":"YqOcIEP9Eh","urlSource":"https://img.shields.io/badge/made%20with-myst-orange"}],"urlSource":"https://myst.tools","key":"OO7Lp32dfE"}],"key":"p1kGUWRlYj"},{"type":"heading","depth":2,"position":{"start":{"line":7,"column":1},"end":{"line":7,"column":1}},"children":[{"type":"text","value":"Getting on the field !","position":{"start":{"line":7,"column":1},"end":{"line":7,"column":1}},"key":"C9rnkTEJgz"}],"identifier":"getting-on-the-field","label":"Getting on the field !","html_id":"getting-on-the-field","implicit":true,"key":"FLyB0Yv5Oz"},{"type":"paragraph","position":{"start":{"line":9,"column":1},"end":{"line":9,"column":1}},"children":[{"type":"image","url":"https://klemet.github.io/Workshop-MagicHarvest/build/Slide22-73c8c73f4090d7070e99455087488fa6.jpg","position":{"start":{"line":9,"column":1},"end":{"line":9,"column":1}},"key":"gfQzzSxkKI","urlSource":"./images/Slide22.jpg"}],"key":"m6bSTfXyxQ"},{"type":"paragraph","position":{"start":{"line":11,"column":1},"end":{"line":11,"column":1}},"children":[{"type":"text","value":"Here, we’re going to see the more technical details of using Magic Harvest :","position":{"start":{"line":11,"column":1},"end":{"line":11,"column":1}},"key":"J0YUtnbPrC"}],"key":"FSo5ZzoGBx"},{"type":"list","ordered":false,"spread":false,"position":{"start":{"line":13,"column":1},"end":{"line":16,"column":1}},"children":[{"type":"listItem","spread":true,"position":{"start":{"line":13,"column":1},"end":{"line":13,"column":1}},"children":[{"type":"text","value":"How to access the state of the LANDIS-II landscape in a Python or R script run with Magic Harvest ?","position":{"start":{"line":13,"column":1},"end":{"line":13,"column":1}},"key":"yGcV3N4HLl"}],"key":"tnqbGqcy8L"},{"type":"listItem","spread":true,"position":{"start":{"line":14,"column":1},"end":{"line":14,"column":1}},"children":[{"type":"text","value":"How to edit the parameter files of Biomass Harvest to control harvesting ?","position":{"start":{"line":14,"column":1},"end":{"line":14,"column":1}},"key":"mOn0QeMoHH"}],"key":"js8DFXNiAA"},{"type":"listItem","spread":true,"position":{"start":{"line":15,"column":1},"end":{"line":16,"column":1}},"children":[{"type":"text","value":"Etc.","position":{"start":{"line":15,"column":1},"end":{"line":15,"column":1}},"key":"XAhknzRLPQ"}],"key":"j43gYmUPZd"}],"key":"pTnHmTQE6W"},{"type":"heading","depth":2,"position":{"start":{"line":17,"column":1},"end":{"line":17,"column":1}},"children":[{"type":"text","value":"Looking at some example files for a simple simulation","position":{"start":{"line":17,"column":1},"end":{"line":17,"column":1}},"key":"dUm6zaO7GX"}],"identifier":"looking-at-some-example-files-for-a-simple-simulation","label":"Looking at some example files for a simple simulation","html_id":"looking-at-some-example-files-for-a-simple-simulation","implicit":true,"key":"mt08zvEo1w"},{"type":"paragraph","position":{"start":{"line":19,"column":1},"end":{"line":19,"column":1}},"children":[{"type":"image","url":"https://klemet.github.io/Workshop-MagicHarvest/build/Slide23-5ca2a1b88a420b071221934f4703621c.jpg","position":{"start":{"line":19,"column":1},"end":{"line":19,"column":1}},"key":"QJ9dwHGTor","urlSource":"./images/Slide23.jpg"}],"key":"AbuH1JCUNn"},{"type":"paragraph","position":{"start":{"line":21,"column":1},"end":{"line":21,"column":1}},"children":[{"type":"text","value":"First of all, I’m going to show you some screenshots of a test scenario with Magic Harvest, with ","position":{"start":{"line":21,"column":1},"end":{"line":21,"column":1}},"key":"sTcbJG93OX"},{"type":"link","url":"https://github.com/Klemet/LANDIS-II-Magic-Harvest/tree/main/Examples/Core-v8/Biomass%20Harvest","position":{"start":{"line":21,"column":1},"end":{"line":21,"column":1}},"children":[{"type":"text","value":"the test files that are on the repository of Magic Harvest","position":{"start":{"line":21,"column":1},"end":{"line":21,"column":1}},"key":"Mx6SXbABb5"}],"urlSource":"https://github.com/Klemet/LANDIS-II-Magic-Harvest/tree/main/Examples/Core-v8/Biomass%20Harvest","error":true,"key":"PaDEyWzk2n"},{"type":"text","value":". Just so that you have a visual idea of what it looks like in action.","position":{"start":{"line":21,"column":1},"end":{"line":21,"column":1}},"key":"uKI6OgbRxU"}],"key":"MXv3ilmLMR"},{"type":"paragraph","position":{"start":{"line":23,"column":1},"end":{"line":23,"column":1}},"children":[{"type":"text","value":"Here is the scenario file that we have quickly seen before; as you see, Magic Harvest is indicated before B. Harvest, and the disturbance order is not random. The path points to the parameter text file of magic harvest. Here is the magic harvest parameter file, that we also have seen before; it’s very simple, and launches a Python script that simply switches the name of files to activate a different B. Harvest parameter text files.","position":{"start":{"line":23,"column":1},"end":{"line":23,"column":1}},"key":"N4vqO6fdyP"}],"key":"rG1kWNGrvt"},{"type":"thematicBreak","position":{"start":{"line":25,"column":1},"end":{"line":25,"column":1}},"key":"Xq5YJudY3Z"},{"type":"paragraph","position":{"start":{"line":27,"column":1},"end":{"line":27,"column":1}},"children":[{"type":"image","url":"https://klemet.github.io/Workshop-MagicHarvest/build/Slide24-0363552cdcd396d343797d282e95cce4.jpg","position":{"start":{"line":27,"column":1},"end":{"line":27,"column":1}},"key":"UDyMNEkIUU","urlSource":"./images/Slide24.jpg"}],"key":"YW0W220Pqu"},{"type":"paragraph","position":{"start":{"line":29,"column":1},"end":{"line":29,"column":1}},"children":[{"type":"text","value":"Here is the Python script launched by Magic Harvest everytime it runs. You see, it’s very simple. It simply renames files to switch between two sets of input files for B. Harvest. This is one of the simplest ways you can influence B. Harvest; you don’t even edit files, you just switch them.","position":{"start":{"line":29,"column":1},"end":{"line":29,"column":1}},"key":"R3ulKC9xLH"}],"key":"HqwhsfwtUZ"},{"type":"thematicBreak","position":{"start":{"line":31,"column":1},"end":{"line":31,"column":1}},"key":"fxZrMgFFGh"},{"type":"paragraph","position":{"start":{"line":33,"column":1},"end":{"line":33,"column":1}},"children":[{"type":"image","url":"https://klemet.github.io/Workshop-MagicHarvest/build/Slide25-c79d8511ec0c378a77ce582c13dff7b5.jpg","position":{"start":{"line":33,"column":1},"end":{"line":33,"column":1}},"key":"C4RMDR8JyR","urlSource":"./images/Slide25.jpg"}],"key":"X2wu7uOsNK"},{"type":"paragraph","position":{"start":{"line":35,"column":1},"end":{"line":35,"column":1}},"children":[{"type":"text","value":"And finally, here is the log of LANDIS-II when it is running. As you see, Magic Harvest writes in the log when it activates, when it’s done running, and when it re-loads the parameters of B. Harvest. We can even see the “print” statements that come from the Python script, and which indicate what the script is doing ! ","position":{"start":{"line":35,"column":1},"end":{"line":35,"column":1}},"key":"LjNJHouAdv"},{"type":"strong","position":{"start":{"line":35,"column":1},"end":{"line":35,"column":1}},"children":[{"type":"text","value":"This is great for debugging","position":{"start":{"line":35,"column":1},"end":{"line":35,"column":1}},"key":"FRl4bqAjhV"}],"key":"Lgc3NesKFK"},{"type":"text","value":". If B. Harvest is not installed or used in the simulation, Magic Harvest will warn you of it.","position":{"start":{"line":35,"column":1},"end":{"line":35,"column":1}},"key":"BBZFdfNRrZ"}],"key":"QS9OQWjuyK"},{"type":"admonition","kind":"caution","children":[{"type":"admonitionTitle","children":[{"type":"text","value":"Caution","key":"Qd2hZFKx0E"}],"key":"kMrori3NLy"},{"type":"paragraph","position":{"start":{"line":38,"column":1},"end":{"line":38,"column":1}},"children":[{"type":"text","value":"The print statements from your R or Python script will not be recorded in the LANDIS-II log text file that LANDIS-II generates during the simulation. But they will be seen in your console.","position":{"start":{"line":38,"column":1},"end":{"line":38,"column":1}},"key":"SaFltpbUDs"}],"key":"LoxBwoREz2"}],"key":"WN4AT5dlUa"},{"type":"heading","depth":2,"position":{"start":{"line":41,"column":1},"end":{"line":41,"column":1}},"children":[{"type":"text","value":"Taking a look at a Python script template","position":{"start":{"line":41,"column":1},"end":{"line":41,"column":1}},"key":"UzdOtxkiA7"}],"identifier":"taking-a-look-at-a-python-script-template","label":"Taking a look at a Python script template","html_id":"taking-a-look-at-a-python-script-template","implicit":true,"key":"VBWqKMxqJ1"},{"type":"paragraph","position":{"start":{"line":43,"column":1},"end":{"line":43,"column":1}},"children":[{"type":"image","url":"https://klemet.github.io/Workshop-MagicHarvest/build/Slide26-ffb0aa62ca811d037b33e7353568a6f4.jpg","position":{"start":{"line":43,"column":1},"end":{"line":43,"column":1}},"key":"eahjidnIgA","urlSource":"./images/Slide26.jpg"}],"key":"W0S6UTA5mL"},{"type":"paragraph","position":{"start":{"line":45,"column":1},"end":{"line":45,"column":1}},"children":[{"type":"text","value":"Now, I’m going to show you a “template” of a Python script I’ve been using in my PhD thesis and my post-doctoral work. This template reads the state of the landscape and other things, and then writes some files to give to B. Harvest. The rest (the management decisions based on the state of the landscape) are up to you to write. We’ll use this template as a base for the following exercice. ","position":{"start":{"line":45,"column":1},"end":{"line":45,"column":1}},"key":"JNItaQ21KJ"},{"type":"link","url":"https://klemet.github.io/Workshop-MagicHarvest/build/magicHarvest_pythonT-5e3c65352679e040f1cbfb63112fd97b.py","position":{"start":{"line":45,"column":1},"end":{"line":45,"column":1}},"children":[{"type":"text","value":"You can download the full file here","position":{"start":{"line":45,"column":1},"end":{"line":45,"column":1}},"key":"wkQztHe3jS"}],"urlSource":"./files/magicHarvest_pythonTemplate.py","static":true,"protocol":"file","key":"TSPtpRJEdr"},{"type":"text","value":".","position":{"start":{"line":45,"column":1},"end":{"line":45,"column":1}},"key":"sVgrEgHq9y"}],"key":"nZEb6T4rji"},{"type":"paragraph","position":{"start":{"line":47,"column":1},"end":{"line":47,"column":1}},"children":[{"type":"text","value":"So first off, a warning : ","position":{"start":{"line":47,"column":1},"end":{"line":47,"column":1}},"key":"TaUTeqo0px"},{"type":"strong","position":{"start":{"line":47,"column":1},"end":{"line":47,"column":1}},"children":[{"type":"text","value":"the template I’m about to show you is complex","position":{"start":{"line":47,"column":1},"end":{"line":47,"column":1}},"key":"RYmv4UiL2K"}],"key":"EBhrJ1oyS0"},{"type":"text","value":", even though I have removed any management decisions. You have to understand that I’ve spent years working on this script through two chapters of my thesis, and then my post-doc work. It’s full of functions made to do things quickly and in an optimized way. It’s also made to adapt to the pretty complex forms of management decision I’ve been making. So what I am about to show you is going to be overwelming. As such, ","position":{"start":{"line":47,"column":1},"end":{"line":47,"column":1}},"key":"QsV7fCfvkK"},{"type":"strong","position":{"start":{"line":47,"column":1},"end":{"line":47,"column":1}},"children":[{"type":"text","value":"I propose that you to not try to understand or read or remember everything","position":{"start":{"line":47,"column":1},"end":{"line":47,"column":1}},"key":"Tciy22mAqR"}],"key":"xY5sOyzjTy"},{"type":"text","value":". In the future, you might use this template for your own work; it is very heavily commented, and you will have the time to understand it piece by piece. ","position":{"start":{"line":47,"column":1},"end":{"line":47,"column":1}},"key":"i4ZT0AmR9g"},{"type":"strong","position":{"start":{"line":47,"column":1},"end":{"line":47,"column":1}},"children":[{"type":"text","value":"Here, I simply want to give you a glimpse under the hood to show you what the engine can look like","position":{"start":{"line":47,"column":1},"end":{"line":47,"column":1}},"key":"HhXcXX432J"}],"key":"UzNp04g6lp"},{"type":"text","value":".","position":{"start":{"line":47,"column":1},"end":{"line":47,"column":1}},"key":"NQxtWd3lEW"}],"key":"w8UNafkoU7"},{"type":"paragraph","position":{"start":{"line":49,"column":1},"end":{"line":49,"column":1}},"children":[{"type":"text","value":"You might also feel like it’s not normal for this methodology to get this complicated; that Magic Harvest is nice, but that this is just too much work and complexity. It’s something I have often felt when working on this. But here, we are working a trade-off : Magic Harvest allow us to become free from the restrictive and pre-defined algorithms of LANDIS-II and do whatever we want, which is essential to our research; but the trade-off is that we have to write the code for that, and it gets complex; just like the code inside LANDIS-II is. It’s just that usually, we don’t touch the LANDIS-II code as users. Here, we have to code everything. That’s the trade-off.","position":{"start":{"line":49,"column":1},"end":{"line":49,"column":1}},"key":"lNjCzsaz0P"}],"key":"IjfkNSFSgh"},{"type":"paragraph","position":{"start":{"line":51,"column":1},"end":{"line":51,"column":1}},"children":[{"type":"text","value":"We could, of course, code a whole new harvest extension for LANDIS-II instead of using a script like this; but this become restrictive again because you have to deal with the complex building process of extensions in the C# langage that LANDIS-II uses, you have to maintain them, and then future users become restricted by your algorithm. By using R or Python scripts, we can use simpler programming langages that most ecologist know to some degree, and we can share our scripts easily, and they can be re-used easily. So, no solution is perfect; but while this one is complex, it works realiably and gives us a high level of control.","position":{"start":{"line":51,"column":1},"end":{"line":51,"column":1}},"key":"IGckjM3vsd"}],"key":"M9LgXUPVgF"},{"type":"paragraph","position":{"start":{"line":53,"column":1},"end":{"line":53,"column":1}},"children":[{"type":"text","value":"So, ready ? Let’s dig in.","position":{"start":{"line":53,"column":1},"end":{"line":53,"column":1}},"key":"Us59EqdWdf"}],"key":"DNsEp0OXtt"},{"type":"heading","depth":3,"position":{"start":{"line":55,"column":1},"end":{"line":55,"column":1}},"children":[{"type":"text","value":"Defining functions for everything","position":{"start":{"line":55,"column":1},"end":{"line":55,"column":1}},"key":"broZbPXdrL"}],"identifier":"defining-functions-for-everything","label":"Defining functions for everything","html_id":"defining-functions-for-everything","implicit":true,"key":"BMYR07xdUX"},{"type":"paragraph","position":{"start":{"line":57,"column":1},"end":{"line":57,"column":1}},"children":[{"type":"text","value":"The beginning of this template is simply a section where a lot of functions are defined so that we can use them afterwards. I really advise you define functions like this. It makes the rest of the code much clearer. In Python, it is really easy to describe each function you’re writting, in particular its inputs and outputs, via a “docstring”, a string of text that documents the function. Modern text editors allow you to write it quickly. AI can write it for you too.","position":{"start":{"line":57,"column":1},"end":{"line":57,"column":1}},"key":"OWdgz0Iajs"}],"key":"pi7IfpPNTj"},{"type":"paragraph","position":{"start":{"line":59,"column":1},"end":{"line":59,"column":1}},"children":[{"type":"text","value":"Here is an example in the script :","position":{"start":{"line":59,"column":1},"end":{"line":59,"column":1}},"key":"SBpTRkN4XB"}],"key":"GKrltixCAl"},{"type":"code","lang":"python","value":"def readingStandsCoordinates(standRasterDataAll, disableTQDM):\n    '''Reads the stands map to get the coordinates of each pixel in a stand.\n    Returns a dictionnary giving the coordinates for each pixel for a given\n    stand ID. Locations are in (row, column) tuple format, as necessary to\n    access a value in a numpy array made from a raster by Rasterio.\n    standRasterDataAll must be a numpy array contained the data from your raster map.'''\n    print(\"Reading stands coordinates...\")\n    standCoordinatesDict = dict()\n    uniqueAllStandsID = np.unique(standRasterDataAll).tolist()\n    # id 0 for stands = no forests\n    uniqueAllStandsID.remove(0)\n    for standID in tqdm(uniqueAllStandsID, disable = disableTQDM):\n        # print(standID)\n        standCoordinatesDict[standID] = list()\n    for x in tqdm(range(standRasterDataAll.shape[0]), disable = disableTQDM):\n        for y in range(standRasterDataAll.shape[1]):\n            standID = standRasterDataAll[(x, y)]\n            if standID != 0:\n                standCoordinatesDict[standID].append((x, y))\n    return(standCoordinatesDict)","position":{"start":{"line":61,"column":1},"end":{"line":82,"column":1}},"key":"aJBLYHp2AA"},{"type":"paragraph","position":{"start":{"line":84,"column":1},"end":{"line":84,"column":1}},"children":[{"type":"text","value":"There’s a lot of functions here. The first ones are used to easily read and write raster map data. When we read raster map data, we put it in a “numpy” array - numpy being a very famous Python package that allows for extremely efficient vectorial, matricial, or generally multi-dimensional array computation. So we put the values of the raster in a 2-dimensional array.","position":{"start":{"line":84,"column":1},"end":{"line":84,"column":1}},"key":"h1EHc1y5cB"}],"key":"awoAZzmHD8"},{"type":"code","lang":"python","value":"def getRasterData(path):\n    raster = gdal.Open(path)\n    rasterData = raster.GetRasterBand(1)\n    rasterData = rasterData.ReadAsArray()\n    return(np.array(rasterData))\n\t\ndef getRasterDataAsList(path):\n    return(getRasterData(path).tolist())\n\ndef writeNewRasterData(rasterDataArray, pathOfTemplateRaster, pathOfOutput):\n    # Saves a raster in int16 with a nodata value of 0\n    # Inspired from https://gis.stackexchange.com/questions/164853/reading-modifying-and-writing-a-geotiff-with-gdal-in-python\n    # Loading template raster\n    template = gdal.Open(pathOfTemplateRaster)\n    driver = gdal.GetDriverByName(\"GTiff\")\n    [rows, cols] = template.GetRasterBand(1).ReadAsArray().shape\n    outputRaster = driver.Create(pathOfOutput, cols, rows, 1, gdal.GDT_Int16)\n    outputRaster.SetGeoTransform(template.GetGeoTransform())##sets same geotransform as input\n    outputRaster.SetProjection(template.GetProjection())##sets same projection as input\n    outputRaster.GetRasterBand(1).WriteArray(rasterDataArray)\n    outputRaster.GetRasterBand(1).SetNoDataValue(0)##if you want these values transparent\n    outputRaster.FlushCache() ##saves to disk!!\n    outputRaster = None\n    \ndef writeNewRasterDataFloat32(rasterDataArray, pathOfTemplateRaster, pathOfOutput):\n    # Saves a raster in Float32 with a nodata value of 0.0\n    # Inspired from https://gis.stackexchange.com/questions/164853/reading-modifying-and-writing-a-geotiff-with-gdal-in-python\n    # Loading template raster\n    template = gdal.Open(pathOfTemplateRaster)\n    driver = gdal.GetDriverByName(\"GTiff\")\n    [rows, cols] = template.GetRasterBand(1).ReadAsArray().shape\n    outputRaster = driver.Create(pathOfOutput, cols, rows, 1, gdal.GDT_Float32)\n    outputRaster.SetGeoTransform(template.GetGeoTransform())##sets same geotransform as input\n    outputRaster.SetProjection(template.GetProjection())##sets same projection as input\n    outputRaster.GetRasterBand(1).WriteArray(rasterDataArray)\n    outputRaster.GetRasterBand(1).SetNoDataValue(0)##if you want these values transparent\n    outputRaster.FlushCache() ##saves to disk!!\n    outputRaster = None\n\ndef writeExistingRasterData(rasterDataArray, pathOfRasterToEdit):\n    # Edits the data of an existing raster\n    rasterToEdit = gdal.Open(pathOfRasterToEdit, gdal.GF_Write)\n    rasterToEdit.GetRasterBand(1).WriteArray(rasterDataArray)\n    rasterToEdit.FlushCache() ##saves to disk!!\n    rasterToEdit = None","position":{"start":{"line":86,"column":1},"end":{"line":132,"column":1}},"key":"JFmH33D2Qc"},{"type":"paragraph","position":{"start":{"line":134,"column":1},"end":{"line":134,"column":1}},"children":[{"type":"text","value":"Then, we have functions that read the state and structure of the landscape in LANDIS-II. To do that, we use input and output raster maps and files from LANDIS-II that will be in our simulation folder. Of course, when LANDIS-II runs, it has its own internal variables that contain the information on the landscape; but sadly, we cannot access these. These variables are contained in the RAM of your computer, and they are only accessible to the program. Since the script we are using is outside LANDIS-II - it’s run through Python, not LANDIS-II -, then we cannot access these internal variables of LANDIS-II.","position":{"start":{"line":134,"column":1},"end":{"line":134,"column":1}},"key":"lAJpY6ldMb"}],"key":"VM45pRT9PY"},{"type":"paragraph","position":{"start":{"line":136,"column":1},"end":{"line":136,"column":1}},"children":[{"type":"text","value":"But that’s fine, because we can use output extensions and some input files of LANDIS-II to get everything we need.","position":{"start":{"line":136,"column":1},"end":{"line":136,"column":1}},"key":"vQjUwxAVJn"}],"key":"XRJCkT2aP9"},{"type":"paragraph","position":{"start":{"line":138,"column":1},"end":{"line":138,"column":1}},"children":[{"type":"text","value":"For example, to get the forest stands in the landscape, we can read the map of forest stands - the one that is usually given to B. Harvest.","position":{"start":{"line":138,"column":1},"end":{"line":138,"column":1}},"key":"W7TTe5YfwG"}],"key":"ZFR2wHdu8e"},{"type":"code","lang":"python","value":"def readingStandsCoordinates(standRasterDataAll, disableTQDM):\n    '''Reads the stands map to get the coordinates of each pixel in a stand.\n    Returns a dictionnary giving the coordinates for each pixel for a given\n    stand ID. Locations are in (row, column) tuple format, as necessary to\n    access a value in a numpy array made from a raster by Rasterio.\n    standRasterDataAll must be a numpy array contained the data from your raster map.'''\n    print(\"Reading stands coordinates...\")\n    standCoordinatesDict = dict()\n    uniqueAllStandsID = np.unique(standRasterDataAll).tolist()\n    # id 0 for stands = no forests\n    uniqueAllStandsID.remove(0)\n    for standID in tqdm(uniqueAllStandsID, disable = disableTQDM):\n        # print(standID)\n        standCoordinatesDict[standID] = list()\n    for x in tqdm(range(standRasterDataAll.shape[0]), disable = disableTQDM):\n        for y in range(standRasterDataAll.shape[1]):\n            standID = standRasterDataAll[(x, y)]\n            if standID != 0:\n                standCoordinatesDict[standID].append((x, y))\n    return(standCoordinatesDict)","position":{"start":{"line":140,"column":1},"end":{"line":161,"column":1}},"key":"YXCg7ZGbTE"},{"type":"paragraph","position":{"start":{"line":163,"column":1},"end":{"line":163,"column":1}},"children":[{"type":"text","value":"For informations about the harvest prescriptions, we can simple “parse” the B. Harvest parameters text file. This is a bit more tricky, but the function is already there, and allows us to put all informations into a Python dictionnary. The dictionnaries of Python is an object that I love very much and use very often : it simply associate an object (e.g. a number, a sentence or a word, or any other object) with another. Here, by reading the harvest parameter text file, I created a big dictionnary that contains the information and rules about each prescription in there. This can be useful, for example, to estimate how much biomass these prescription will harvest in the cells. Making this estimation can be used to know if we have reached the targets we have for the current timestep.","position":{"start":{"line":163,"column":1},"end":{"line":163,"column":1}},"key":"OWRXI3lTWp"}],"key":"meeo5ZLERM"},{"type":"code","lang":"python","value":"def harvestParameterFileParser(path):\n    \"\"\"\n    Parses the biomass harvest parameter file at the given path.\n    Returns a dictionnary with the needed parameters.\n    \n    WARNING : To read the harvest file properly, make sure to :\n    - Not use relative number of cohorts harvested for a given species, like\n      \"1/2\" or \"1/3\". Since this script is made to be used with biomass harvest,\n      use things like \"11-999(50%)\" to harvest half of the biomass of each cohort.\n    - Make sure the biomass percentages are not separated from their respective\n      age class, meaning write \"11-999(50%)\" rather than \"11-999 (50%)\"\n    \"\"\"\n    print(\"Reading harvest parameter file...\")\n    \n    dictToReturn = dict()\n    \n    # WARNING : Here is the list of species I use. Replace it with your own species\n    # codes that you use in LANDIS-II !\n    speciesList = [\"ABIE.BAL\",\"ACER.RUB\",\"ACER.SAH\",\"BETU.ALL\",\"BETU.PAP\",\n                   \"FAGU.GRA\",\"LARI.LAR\",\"LARI.HYB\",\"PICE.GLA\",\"PICE.MAR\",\n                   \"PICE.RUB\",\"PINU.BAN\",\"PINU.RES\",\"PINU.STR\",\"POPU.TRE\",\n                   \"POPU.HYB\",\"QUER.RUB\",\"THUJ.SPP.ALL\",\"TSUG.CAN\"]\n    \n    with open(path, 'r') as file:\n        prescriptionSelected = \"none\"\n        prescriptionID = 1 # We start at 1 because the ID is for the raster;\n        # 0 = not forest, 1 = forest not harvested, and then it's the prescriptions.\n        for line in file:\n            # print(line)\n            # We start by recording the lines if we're reading a prescription\n            if prescriptionSelected != \"none\" and \"Prescription \" not in line:\n                dictToReturn[prescriptionSelected][\"FullString\"].append(line)\n            if \"\u003e\u003e-------------\" in line:\n                prescriptionSelected = \"none\"\n                \n            # We get the timestep used by the extension\n            if \"Timestep\" in line:\n                timestepLength = int(splitLineAndRemoveTabsAndSpaces(line)[1])\n            # If we find a new prescription, we initialize everything needed\n            if \"Prescription \" in line:\n                prescriptionSelected = line[len(\"Prescription \"):-1] #-1 removes the \\n character at the end of each line\n                if prescriptionSelected not in dictToReturn:\n                    dictToReturn[prescriptionSelected] = dict()\n                    dictToReturn[prescriptionSelected][\"Planting\"] = \"none\"\n                    dictToReturn[prescriptionSelected][\"RepeatMode\"] = \"none\"\n                    dictToReturn[prescriptionSelected][\"MaximumStandAge\"] = 999\n                    dictToReturn[prescriptionSelected][\"MinimumStandAge\"] = 0\n                    dictToReturn[prescriptionSelected][\"Commercial\"] = True # Does it generate merchantable wood ?\n                    dictToReturn[prescriptionSelected][\"FullString\"] = [line] # We keep all the lines of the prescription to be able to copy it to make different plantings\n                    prescriptionID += 1\n                    dictToReturn[\"_MaxPrescriptionID\"] = prescriptionID # Special counter used to create new planting prescriptions later\n                    dictToReturn[prescriptionSelected][\"PrescriptionID\"] = prescriptionID\n                singleRepeat = False\n            \n            # Else, we register the parameters of the prescription\n            elif \"MaximumAge\" in line:\n                maximumAge = splitLineAndRemoveTabsAndSpaces(line)[1]\n                dictToReturn[prescriptionSelected][\"MaximumStandAge\"] = int(maximumAge)\n            elif \"MinimumAge\" in line:\n                minimumAge = splitLineAndRemoveTabsAndSpaces(line)[1]\n                dictToReturn[prescriptionSelected][\"MinimumStandAge\"] = int(minimumAge)\n            elif \"SiteSelection\" in line:\n                # The line contains 2 words + the two numerical values we want\n                # We remove everything we don't need to get the two values\n                splittedLine = splitLineAndRemoveTabsAndSpaces(line)\n                # print(splittedLine)\n                dictToReturn[prescriptionSelected][\"HarvestPropagation\"] = [float(splittedLine[2]), float(splittedLine[3])]\n            elif \"CohortsRemoved\" in line and not singleRepeat:\n                dictToReturn[prescriptionSelected][\"CohortRemoved\"] = dict()\n            elif \"Planting\" in line:\n                plantingString = splitLineAndRemoveTabsAndSpaces(line)[1]\n                dictToReturn[prescriptionSelected][\"Planting\"] = plantingString\n            elif \"Commercial\" in line and \"FALSE\" in line.upper():\n                dictToReturn[prescriptionSelected][\"Commercial\"] = False\n            elif \"SingleRepeat\" in line:\n                singleRepeat = True\n                dictToReturn[prescriptionSelected][\"CohortRemoved\"][\"SingleRepeat\"] = dict()\n                dictToReturn[prescriptionSelected][\"RepeatMode\"] = \"SingleRepeat\"\n                repeatFrenquency = splitLineAndRemoveTabsAndSpaces(line)[1]\n                dictToReturn[prescriptionSelected][\"RepeatFrequency\"] = int(repeatFrenquency)\n            elif \"MultipleRepeat\" in line:\n                dictToReturn[prescriptionSelected][\"RepeatMode\"] = \"MultipleRepeat\"\n                repeatFrenquency = splitLineAndRemoveTabsAndSpaces(line)[1]\n                dictToReturn[prescriptionSelected][\"RepeatFrequency\"] = int(repeatFrenquency)\n                \n            # If we get to the part about the cohort removed, it's a bit more tricky\n            # to register\n            # In particular, we will register the cohort removed in the case of a\n            # second pass (via SingleRepeat) in a different nested dictionnary\n            for species in speciesList:\n                if species in line and \"Prescription \" not in line and \"Plant\" not in line:\n                    if not singleRepeat:\n                        dictToReturn[prescriptionSelected][\"CohortRemoved\"][species] = dict()\n                    else:\n                        dictToReturn[prescriptionSelected][\"CohortRemoved\"][\"SingleRepeat\"][species] = dict()\n                    # 3 cases :\n                    # just ages (11-999)\n                    # \"All\" keyword\n                    # ages categories with biomass percent (11-999(90%))\n                    # print(line)\n                    if \"/\" in line: # Just in case their are relative cohort numbers in the file\n                        raise ValueError(\"Do not use relative number of cohort harvested for a given species, like \\\"1/2\\\" or \\\"1/3\\\". Since this script is made to be used with biomass harvest, use things like \\\"11-999(50%)\\\" to harvest half of the biomass of each cohort.\")\n                    elif \"All\" in line or \"all\" in line:\n                        if not singleRepeat:\n                            dictToReturn[prescriptionSelected][\"CohortRemoved\"][species] = \"All\"\n                        else:\n                            dictToReturn[prescriptionSelected][\"CohortRemoved\"][\"SingleRepeat\"][species] = \"All\"\n                    else: # If not all, we have to break appart the age categories\n                        if not singleRepeat:\n                            dictToReturn[prescriptionSelected][\"CohortRemoved\"][species] = list()\n                        else:\n                            dictToReturn[prescriptionSelected][\"CohortRemoved\"][\"SingleRepeat\"][species] = list()\n                        splittedLine = splitLineAndRemoveTabsAndSpaces(line)\n                        # print(splittedLine)\n                        for ageCategory in splittedLine[1:]:\n                            if \"%\" not in ageCategory:\n                                splitAgeCategory = ageCategory.split(\"-\")\n                                # We add a list describing 1) min age of category 2) max age of category 3) % of biomass harvested\n                                if not singleRepeat:\n                                    dictToReturn[prescriptionSelected][\"CohortRemoved\"][species].append([int(splitAgeCategory[0]), int(splitAgeCategory[1]), 100])\n                                else:\n                                    dictToReturn[prescriptionSelected][\"CohortRemoved\"][\"SingleRepeat\"][species].append([int(splitAgeCategory[0]), int(splitAgeCategory[1]), 100])\n                            else:\n                                splitAgeCategory = ageCategory.replace(\"(\", \"-\").replace(\"%)\", \"\").split(\"-\")\n                                if not singleRepeat:\n                                    dictToReturn[prescriptionSelected][\"CohortRemoved\"][species].append([int(splitAgeCategory[0]), int(splitAgeCategory[1]), int(splitAgeCategory[2])])\n                                else:\n                                    dictToReturn[prescriptionSelected][\"CohortRemoved\"][\"SingleRepeat\"][species].append([int(splitAgeCategory[0]), int(splitAgeCategory[1]), int(splitAgeCategory[2])])\n                        \n            if \"HarvestImplementations\" in line:\n                break\n                \n    return(dictToReturn, timestepLength)","position":{"start":{"line":165,"column":1},"end":{"line":299,"column":1}},"key":"wHRuuoS1ny"},{"type":"paragraph","position":{"start":{"line":301,"column":1},"end":{"line":301,"column":1}},"children":[{"type":"text","value":"Now, I’ve shown a function to read the stands, and one to read the B. Harvest parameter text file; but how do we get the vegetation data ? How do we know exactly what’s inside each cell in the landscape ? The age cohorts and their biomass ? Took me a while, but I found a great way. There is an output extension called ","position":{"start":{"line":301,"column":1},"end":{"line":301,"column":1}},"key":"XvzE1o5DgV"},{"type":"link","url":"https://github.com/LANDIS-II-Foundation/Extension-Output-Biomass-Community","position":{"start":{"line":301,"column":1},"end":{"line":301,"column":1}},"children":[{"type":"text","value":"Biomass Community Output","position":{"start":{"line":301,"column":1},"end":{"line":301,"column":1}},"key":"l5rtw680Ky"}],"urlSource":"https://github.com/LANDIS-II-Foundation/Extension-Output-Biomass-Community","error":true,"key":"Lh5XcispER"},{"type":"text","value":" that, at each time step, exports the entire landscape as a raster map + a communities csv file that is exactly like the ones that are used for the initial conditions of LANDIS-II. These files are very large, as they contain the most “raw” data that LANDIS-II can output. But with a bit of optimisation, Python can read them very quickly and put them into a dictionnary. In this dictionnary, we can access the age cohorts of each pixels of a given stand, their age, and their biomass. That gives us all of the information we will ever need to make management decisions.","position":{"start":{"line":301,"column":1},"end":{"line":301,"column":1}},"key":"yKJgMMfZ8o"}],"key":"pjj4UP6oo3"},{"type":"code","lang":"python","value":"def readCommunitiesComplete(communityCsvPath,\n                            communityMapPath,\n                            standCoordinatesDict,\n                            disableTQDM):\n    \"\"\"\n    Reads the communities csv and raster map made by Output Biomass Community\n    to make a dictionnary containing the species and age cohorts for each\n    species and biomass for these cohorts for all of the pixels of a stand.\n    WARNING : the dictionnary doesn't contain entries for stands that have\n    no cohorts/no biomass, and no entries for species that are not in a stand\n    or cohorts that do not exist for a species. This saves on a lot of space,\n    but one got to check if the entries are there when using the dictionnary.\n    \"\"\"\n\n    # communityCsvPath = \"./community-input-file-\" + str(timestep) + \".csv\"\n    # communityMapPath = \"./output-community-\" + str(timestep) + \".img\"\n    print(\"Reading communities csv and map...\")\n    # We only need the mapcode column from the csv from now.\n    communityCsv = pd.read_csv(communityCsvPath, usecols=['MapCode'])\n    communityMapCodeData = getRasterData(communityMapPath)\n\n    # We make the dictionnary of the amount of times a stand is associated\n    # to a mapcode\n    print(\"Creating mapcode community dictionnary...\")\n    dictMapCodeStands = dict()\n    for uniqueMapCode in communityCsv[\"MapCode\"].unique():\n        dictMapCodeStands[uniqueMapCode] = dict()\n        \n    for standID in standCoordinatesDict.keys():\n        for pixel in standCoordinatesDict[standID]:\n            mapcode = communityMapCodeData[pixel]\n            # If the mapcode is not already in the dictionnary, it was not in\n            # the CSV; and if it's not in the CSV, it's because it's a mapcode\n            # associated to no cohorts at all(total biomass of 0)\n            if mapcode in dictMapCodeStands:\n                if standID not in dictMapCodeStands[mapcode]:\n                    dictMapCodeStands[mapcode][standID] = 1\n                else:\n                    dictMapCodeStands[mapcode][standID] += 1\n    \n    # Now, we can read the CSV file and fill in a second dictionnary with the\n    # information for each stand\n    # To lighten it, we won't put stands that have no biomass\n    # (IMPORTANT FOR OTHER FUNCTIONS : have to check if stand is in dictionnary)\n    print(\"Creating stand community dictionnary...\")\n    \n    standCommunitiesDict = dict()\n    with open(communityCsvPath, 'r') as file:\n        reader = csv.reader(file)\n        headers = next(reader)  # Read the header row\n        for row in tqdm(reader, total=len(communityCsv[\"MapCode\"]), disable = disableTQDM):\n            # 0 is mapcode; 1 is species; 2 is cohort; 3 is biomass.\n            for standID in dictMapCodeStands[int(row[0])]:\n                if standID not in standCommunitiesDict:\n                    standCommunitiesDict[standID] = dict()\n                    standCommunitiesDict[standID][row[1]] = dict()\n                    standCommunitiesDict[standID][row[1]][int(row[2])] = 0\n                # If species not indicated for this stand, we put it\n                elif row[1] not in standCommunitiesDict[standID]:\n                    standCommunitiesDict[standID][row[1]] = dict()\n                    standCommunitiesDict[standID][row[1]][int(row[2])] = 0\n                # If age cohort not indicated for this stand/species, we put it\n                elif int(row[2]) not in standCommunitiesDict[standID][row[1]]:\n                    standCommunitiesDict[standID][row[1]][int(row[2])] = 0\n                # Finally, we enter the biomass for the stand/species/cohort\n                # If the stand has multiple pixel with this mapcode, we multiply\n                # the biomass with the number of pixels\n                # WARNING : Need to transform biomass from g/m2 to Mg/ha by dividing by 100\n                standCommunitiesDict[standID][row[1]][int(row[2])] += (int(row[3])/100)*dictMapCodeStands[int(row[0])][standID]\n        \n    return(standCommunitiesDict)","position":{"start":{"line":303,"column":1},"end":{"line":375,"column":1}},"key":"RkroL91Wf4"},{"type":"paragraph","position":{"start":{"line":377,"column":1},"end":{"line":377,"column":1}},"children":[{"type":"text","value":"We then have other functions that can retrieve data we might need for management decisions. These functions used objects created by other functions that contain data about the vegetation. For example :","position":{"start":{"line":377,"column":1},"end":{"line":377,"column":1}},"key":"sY9PcgQTlx"}],"key":"fprx1OfY6J"},{"type":"list","ordered":false,"spread":false,"position":{"start":{"line":379,"column":1},"end":{"line":380,"column":1}},"children":[{"type":"listItem","spread":true,"position":{"start":{"line":379,"column":1},"end":{"line":380,"column":1}},"children":[{"type":"text","value":"Getting the biomass of a list of species we want to harvest in a stand (based on the vegetation data we have put in a dictionnary)","position":{"start":{"line":379,"column":1},"end":{"line":379,"column":1}},"key":"k9tZWoEzXc"}],"key":"TPzBm32Sgw"}],"key":"H2ZyNhpzBz"},{"type":"code","lang":"python","value":"def GetBiomassInstand(standCompositionDict, standID, listOfSpecies):\n    \"\"\"Retrieves the total biomass in a stand for a list of species.\n    Returns a single biomass value.\"\"\"\n    sumOfBiomass = 0\n    for species in listOfSpecies:\n        if species in standCompositionDict[standID]:\n            sumOfBiomass += sum(standCompositionDict[standID][species].values())\n    return(sumOfBiomass)","position":{"start":{"line":381,"column":1},"end":{"line":390,"column":1}},"key":"fliVfuuKcO"},{"type":"list","ordered":false,"spread":false,"position":{"start":{"line":392,"column":1},"end":{"line":393,"column":1}},"children":[{"type":"listItem","spread":true,"position":{"start":{"line":392,"column":1},"end":{"line":393,"column":1}},"children":[{"type":"text","value":"Reading the age of the stands (to see what stand are the oldest)","position":{"start":{"line":392,"column":1},"end":{"line":392,"column":1}},"key":"ZdhjW2Z2E4"}],"key":"SSJV1gFWzL"}],"key":"YuNK9w8LrZ"},{"type":"code","lang":"python","value":"def readingStandsAges(standMapPath, maxAgeMapsFolderPath, timestep, timestepLength, disableTQDM):\n    '''Uses the stand maps and max age map to compute the mean age of each stand\n    (average of the age of the oldest cohorts in each pixels of the stand).\n    Returns a dictionnary associating an age to a stand ID.\n    The max age map is taken from the previous timestep to the current one.'''\n    print(\"Reading stands age...\")\n    \n    standData = getRasterData(standMapPath)\n    uniqueAllStandsID = np.unique(standData).tolist()\n    # id 0 for stands = no forests\n    uniqueAllStandsID.remove(0)\n    cohortMaxAgeData = getRasterData(maxAgeMapsFolderPath + \"AGE-MAX-\" + str(timestep - timestepLength) + \".img\")\n    maxAgeDict = dict()\n    # Little trick to use the power of numpy below\n    # We make an array with the pixels we want the value of, and another\n    # with the values\n    pixelCoordinates = np.where(standData != 0)\n    standIDinPixelCoordinates = standData[pixelCoordinates]\n    for standID in tqdm(uniqueAllStandsID, disable = disableTQDM):\n        maxAgeDict[standID] = list()\n    # We get the data for the harvestable pixels\n    cohortMaxAgeInForestPixel = cohortMaxAgeData[pixelCoordinates]\n    # We fill the dictionnary with the different values of max cohort age for each\n    # pixels in a stand\n    for i in tqdm(range(0, len(pixelCoordinates[0])), disable = disableTQDM):\n        maxAgeDict[standIDinPixelCoordinates[i]].append(cohortMaxAgeInForestPixel[i])\n    # We make a dictionnary containing the mean max age for each stand\n    standAgeDict = dict()\n    for standID in tqdm(uniqueAllStandsID, disable = disableTQDM):\n        standAgeDict[standID] = statistics.mean(maxAgeDict[standID])\n    return(standAgeDict)","position":{"start":{"line":394,"column":1},"end":{"line":426,"column":1}},"key":"QDBdkHqukV"},{"type":"list","ordered":false,"spread":false,"position":{"start":{"line":428,"column":1},"end":{"line":429,"column":1}},"children":[{"type":"listItem","spread":true,"position":{"start":{"line":428,"column":1},"end":{"line":429,"column":1}},"children":[{"type":"text","value":"Reading the management unit associated to each stand (remember that we are going to give non-sensical management area maps to B. Harvest if we want to control its behaviour, but we might still want to use management areas in our Python script to make our management decisions)","position":{"start":{"line":428,"column":1},"end":{"line":428,"column":1}},"key":"Uk3nBJoyFe"}],"key":"nEplzqZeav"}],"key":"S78V2F0hZs"},{"type":"code","lang":"python","value":"def readingStandManagementUnit(standMapPath, managementUnitsMapPath, disableTQDM):\n    '''Assign a management unit (UA) code to each stand. This is not used to define\n    management units per say in our landscape, but rather to get the conversion\n    values from raw to net merchantable volume harvested, based on data from\n    the ministry of forest (the data changes by species and by management unit).\n    See coefficientRawToNetVolumes object for more info.'''\n    print(\"Reading stands management units (used for volume conversion)...\")\n    \n    standData = getRasterData(standMapPath)\n    uniqueAllStandsID = np.unique(standData).tolist()\n    # id 0 for stands = no forests\n    uniqueAllStandsID.remove(0)\n    managementUnitsMap = getRasterData(managementUnitsMapPath)\n    managementUnitDict = dict()\n    # Little trick to use the power of numpy below\n    # We make an array with the pixels we want the value of, and another\n    # with the values\n    pixelCoordinates = np.where(standData != 0)\n    standIDinPixelCoordinates = standData[pixelCoordinates]\n    for standID in tqdm(uniqueAllStandsID, disable = disableTQDM):\n        managementUnitDict[standID] = list()\n    # We get the data for the harvestable pixels\n    managementUnitInPixel = managementUnitsMap[pixelCoordinates]\n    # We fill the dictionnary with the different values of max cohort age for each\n    # pixels in a stand\n    for i in tqdm(range(0, len(pixelCoordinates[0])), disable = disableTQDM):\n        managementUnitDict[standIDinPixelCoordinates[i]].append(managementUnitInPixel[i])\n    # We make a dictionnary containing the mean max age for each stand\n    standManagementUnitDict = dict()\n    for standID in tqdm(uniqueAllStandsID, disable = disableTQDM):\n        standManagementUnitDict[standID] = Counter(managementUnitDict[standID]).most_common(1)[0][0]\n    return(standManagementUnitDict)","position":{"start":{"line":430,"column":1},"end":{"line":463,"column":1}},"key":"pBccq88D94"},{"type":"list","ordered":false,"spread":false,"position":{"start":{"line":465,"column":1},"end":{"line":466,"column":1}},"children":[{"type":"listItem","spread":true,"position":{"start":{"line":465,"column":1},"end":{"line":466,"column":1}},"children":[{"type":"text","value":"Writing in the raster map that we are going to create what pixels will be harvested with a given prescriptions","position":{"start":{"line":465,"column":1},"end":{"line":465,"column":1}},"key":"qO4ybyp5QU"}],"key":"ugTSAlHZ6T"}],"key":"NqpfJBiFsr"},{"type":"code","lang":"python","value":"def harvestStands(managementMap, standsList, standCoordinatesDict, prescriptionID):\n    \"\"\"Edits the management map to indicate a list of stands as harvested with\n    a given prescription ID. Returns the modified management map.\"\"\"\n    numberOfPixelsHarvested = 0\n    for standID in standsList:\n        for pixel in standCoordinatesDict[standID]:\n            managementMap[pixel] = prescriptionID\n            numberOfPixelsHarvested += 1\n    return(managementMap, numberOfPixelsHarvested)","position":{"start":{"line":467,"column":1},"end":{"line":477,"column":1}},"key":"h1nLfoq9P9"},{"type":"list","ordered":false,"spread":false,"position":{"start":{"line":479,"column":1},"end":{"line":480,"column":1}},"children":[{"type":"listItem","spread":true,"position":{"start":{"line":479,"column":1},"end":{"line":480,"column":1}},"children":[{"type":"text","value":"A function to get what are the stands that are the neighbours of a stand if we want to propagate a cut accross several stand","position":{"start":{"line":479,"column":1},"end":{"line":479,"column":1}},"key":"mZ2NrHPEUQ"}],"key":"QHAEuMkIpn"}],"key":"moXhLUamKI"},{"type":"code","lang":"python","value":"def readingStandsNeighbors(standRasterDataAll,\n                           standCoordinatesDict,\n                           disableTQDM = True):\n    '''Reads the neighbors of each stand by looking at the surrounding\n    pixels of those of the stands, and getting their stand ID. Returns a dictionnary\n    with the list of neighbors's stand ID for each stand.'''\n    print(\"Reading stand neighbors...\")\n    \n    # Making a dictionnary which tells what stand is a neighbor of which one.\n    # We only need it for harvestable stands, since this is for the propagation\n    # of cuts.\n    standNeighboursDict = dict()\n    minXRange = range(standRasterDataAll.shape[0])[0]\n    maxXRange = range(standRasterDataAll.shape[0])[-1]\n    minYRange = range(standRasterDataAll.shape[1])[0]\n    maxYRange = range(standRasterDataAll.shape[1])[-1]\n    for standID in tqdm(standCoordinatesDict.keys(), disable = disableTQDM):\n        listOfNeighbouringStands = list()\n        for pixel in standCoordinatesDict[standID]:\n            listOfStandsAroundPixel = list()\n            # We look at the 8 neighbors of the pixel, if not out of range,\n            # to try to detect another stand number\n            # First, we prepare the ranges around which we'll loop, and make sure\n            # we're not out of bounds\n            xMinus1 = max(pixel[0] - 1, minXRange)\n            xPlus1 = min(pixel[0] + 1, maxXRange)\n            yMinus1 = max(pixel[1] - 1, minYRange)\n            yPlus1 = min(pixel[1] + 1, maxYRange)\n            # Now, we loop to find values\n            for x in [xMinus1, pixel[0], xPlus1]:\n                for y in [yMinus1, pixel[1], yPlus1]:\n                    listOfStandsAroundPixel.append(standRasterDataAll[(x, y)])\n            uniqueNeighbouringStands = set(listOfStandsAroundPixel)\n            # We remove mentions of the present stand and of the value 0\n            uniqueNeighbouringStands.discard(standID)\n            uniqueNeighbouringStands.discard(0)\n            listOfNeighbouringStands.extend(list(uniqueNeighbouringStands))\n        # We add the resulting unique standID that we found as neighbors to this stand\n        standNeighboursDict[standID] = set(listOfNeighbouringStands)\n    return(standNeighboursDict)","position":{"start":{"line":481,"column":1},"end":{"line":522,"column":1}},"key":"dF60mCKzqj"},{"type":"list","ordered":false,"spread":false,"position":{"start":{"line":524,"column":1},"end":{"line":525,"column":1}},"children":[{"type":"listItem","spread":true,"position":{"start":{"line":524,"column":1},"end":{"line":525,"column":1}},"children":[{"type":"text","value":"A function to propagate the cuts from stand to stand until we reach a certain size","position":{"start":{"line":524,"column":1},"end":{"line":524,"column":1}},"key":"lIf1SFcKUU"}],"key":"q7hCKBfzw0"}],"key":"YUQKeNslC7"},{"type":"code","lang":"python","value":"def standHarvestPropagation(standID,\n                            prescription,\n                            prescriptionParameters,\n                            standNeighboursDict,\n                            standCoordinatesDict,\n                            standAgeDict):\n    \"\"\"\n    Propagate a harvest prescription from a stand to the neigbouring stands,\n    depending on the selection criteria + min/max harvest size for the\n    prescription.\n    Returns a list of harvested stands.\n    \"\"\"\n    listOfHarvestedStands = list()\n    frontier = [standID]\n    surfaceHarvested = 0\n    while surfaceHarvested \u003c prescriptionParameters[prescription][\"HarvestPropagation\"][1] and len(frontier) \u003e 0:\n        focusStand = frontier.pop(0)\n        # If we overeach the maximum surface, we stop here.\n        if surfaceHarvested + len(standCoordinatesDict[focusStand]) \u003e prescriptionParameters[prescription][\"HarvestPropagation\"][1]:\n            break\n        else:\n            listOfHarvestedStands.append(focusStand)\n            # TO UPDATE : Surface harvested here is dealt in pixels. But in harvest parameter\n            # file, might be in different units than pixel. See how to adapt to that. Need cell length ?\n            surfaceHarvested += len(standCoordinatesDict[standID])\n            for neighbor in standNeighboursDict[focusStand] :\n                if neighbor not in listOfHarvestedStands and standAgeDict[neighbor] \u003e prescriptionParameters[prescription][\"MinimumStandAge\"] and standAgeDict[neighbor] \u003c prescriptionParameters[prescription][\"MaximumStandAge\"]:\n                   frontier.append(neighbor) \n    return(listOfHarvestedStands)","position":{"start":{"line":526,"column":1},"end":{"line":556,"column":1}},"key":"hAJkUYRAMD"},{"type":"paragraph","position":{"start":{"line":558,"column":1},"end":{"line":558,"column":1}},"children":[{"type":"text","value":"I won’t discuss all of the functions that are in the template, but there are a lot of them !","position":{"start":{"line":558,"column":1},"end":{"line":558,"column":1}},"key":"B6wW0OHstb"}],"key":"ZhZxVDIuZ3"},{"type":"paragraph","position":{"start":{"line":560,"column":1},"end":{"line":560,"column":1}},"children":[{"type":"text","value":"So as you see, the first section of this template contains a lot of functions. Many of them actually replace functions that are inside B. Harvest; reading the position of the stands, their age, etc. Again, the trade-off is that here, we have the freedom to do anything we want, but have to re-do it from A to Z. It’s like we’re writing an entire new model in our script. And that’s why these functions are here. The good news is : you won’t have to worry about them one bit ! They’re already ready. So a big, big chunk of the work is already done for you.","position":{"start":{"line":560,"column":1},"end":{"line":560,"column":1}},"key":"hVmc09UVFq"}],"key":"VaWwMyQ7cj"},{"type":"paragraph","position":{"start":{"line":562,"column":1},"end":{"line":562,"column":1}},"children":[{"type":"text","value":"Another cool thing : ","position":{"start":{"line":562,"column":1},"end":{"line":562,"column":1}},"key":"CPm755f9lA"},{"type":"strong","position":{"start":{"line":562,"column":1},"end":{"line":562,"column":1}},"children":[{"type":"text","value":"it’s very easy to test these functions, to understand them or to create news ones","position":{"start":{"line":562,"column":1},"end":{"line":562,"column":1}},"key":"YnPlKGzjSw"}],"key":"IV920xZgJc"},{"type":"text","value":" ! Python is an intepreted langage like R, so you can run commands and interact with it easily. So, you can put your script in a folder containing LANDIS-II inputs and outputs, and you can try it out and see if it works line by line. This makes creating your algorithm and debugging it VASTLY easier than working in C#. In fact, you’ll see in the template a little section that allow you to run the script in “debug mode”.","position":{"start":{"line":562,"column":1},"end":{"line":562,"column":1}},"key":"dECdYCsuiC"}],"key":"kVU4JyBAGN"},{"type":"code","lang":"python","value":"#%% DEBUG\n\n# Just put \"False\" unless you're tinkering with this script.\ndebug = False\n# debug = True\n\n# If debugging, we prepare a dummy situation\nif debug:\n    os.chdir(r\"path/to/your/folder/with/simulation/files/landis-ii\")\n    timestep = 15\n    BAU_Modifier = 1\n    disableTQDM = False\n    import matplotlib.pyplot as plt\nelse:\n    # If not debugging, this Python script is normally called in a command prompt by specifying\n    # some arguments, like the location of the folders containing the files that\n    # we need relative to the LANDIS-II scenario file\n    if __name__ == \"__main__\":\n        # Remember : argument at index 0 contains the program name.\n        # The arguments that we want come after\n        timestep = sys.argv[1]\n        timestep = int(timestep)\n        # You can retrieve other arguments here; just use sys.argv[2], sys.argv[3], etc. \n    # We disable the progress bars of TQDM to not display them in the LANDIS log\n    disableTQDM = True","position":{"start":{"line":564,"column":1},"end":{"line":590,"column":1}},"key":"wYDmFAu8s7"},{"type":"paragraph","position":{"start":{"line":592,"column":1},"end":{"line":592,"column":1}},"children":[{"type":"text","value":"If not in debug mode, you’ll see (see code snippet above) that the script will attempt to gather “arguments” that were given with the command; here, I’m taking the ","position":{"start":{"line":592,"column":1},"end":{"line":592,"column":1}},"key":"nhFTATRTdu"},{"type":"inlineCode","value":"{timestep}","position":{"start":{"line":592,"column":1},"end":{"line":592,"column":1}},"key":"JKxZBC1mlr"},{"type":"text","value":" argument i’ve passed through the Magic Harvest Parameter text file from earlier (which Magic Harvest will transform into the LANDIS-II time step at which the script is launched). This way, I have a variable in my script that contains the current time step. There are other ways to get the current time step - for example, by looking at LANDIS-II output files - but this one is the simplest and most reliable in my opinion.","position":{"start":{"line":592,"column":1},"end":{"line":592,"column":1}},"key":"gVuEQWYEA8"}],"key":"rVnXGeMeWe"},{"type":"heading","depth":3,"position":{"start":{"line":594,"column":1},"end":{"line":594,"column":1}},"children":[{"type":"text","value":"Using functions to read the state of the landscape","position":{"start":{"line":594,"column":1},"end":{"line":594,"column":1}},"key":"kqzsfBTw0I"}],"identifier":"using-functions-to-read-the-state-of-the-landscape","label":"Using functions to read the state of the landscape","html_id":"using-functions-to-read-the-state-of-the-landscape","implicit":true,"key":"UhqZiPbIBD"},{"type":"paragraph","position":{"start":{"line":596,"column":1},"end":{"line":596,"column":1}},"children":[{"type":"text","value":"The second section of the script is then using the functions we’ve just looked at to read files and load the informations of the landscape into Python variables, especially Python dictionnaries.","position":{"start":{"line":596,"column":1},"end":{"line":596,"column":1}},"key":"askvIBQIwk"}],"key":"eeCKXl7njT"},{"type":"code","lang":"python","value":"#%% DEFINING PARAMETERS FOR EACH PRESCRIPTION\n\n# We read the template harvest parameter file, which also contains the parameters needed\n# for magic harvest\nprescriptionParameters, timestepLength = harvestParameterFileParser(\"./input/disturbances/harvesting/harvest_BAU_v2.0_TEMPLATE.txt\")\n\n#%% READING DATA FOR TIME STEP\n\n# Reading files for stand coordinates\nstandRasterData = getRasterData(\"../../sharedRasters/stands_v2.0.tif\")\nstandCoordinatesDict = readingStandsCoordinates(standRasterData,\n                                                disableTQDM)\n\n# Reading raster of Management units (UAs)\nstandUADict = readingStandManagementUnit(\"../../sharedRasters/stands_v2.0.tif\",\n                                         \"../../sharedRasters/rasterUAInterpolated.tif\",\n                                         disableTQDM)\n\n# Reading JSON files for repeated prescriptions\nrepeatPrescriptionPath = \"./input/disturbances/harvesting/temp/repeatedPrescriptions.pickle\"\nif os.path.exists(\"repeatPrescriptionPath\"):\n    with open(repeatPrescriptionPath) as repeatedPrescriptionFile:\n        pickle.load(repeatPrescriptionsDict, repeatedPrescriptionFile)\nelse:\n    repeatPrescriptionsDict = \"noRepeatsForNow\"\n\n# Reading vegetation communities\nstandCompositionDict = readCommunitiesComplete(\"./community-input-file-\" + str(timestep- timestepLength) + \".csv\",\n                                            \"./output-community-\" + str(timestep- timestepLength) + \".img\",\n                                            standCoordinatesDict,\n                                            disableTQDM)\n\n# Reading stand ages\nstandAgeDict = readingStandsAges(\"../../sharedRasters/stands_v2.0.tif\",\n                         \"./output/cohort-stats/\",\n                         timestep,\n                         timestepLength,\n                         disableTQDM)\n\n# Determining forest types\nforestTypesStandsDict = DetermineForestTypesOfStands(standCompositionDict,\n                                                     standCoordinatesDict,\n                                                     disableTQDM)\n\n# Determining management unit for each stand (used for the conversion of\n# raw to net merchantable volume harvested)\n\n# stand neighbors dict (used for stand propagation)\nstandNeighboursDict = readingStandsNeighbors(standRasterData,\n                                            standCoordinatesDict,\n                                            disableTQDM)","position":{"start":{"line":598,"column":1},"end":{"line":650,"column":1}},"key":"dcxzS6Dbvv"},{"type":"paragraph","position":{"start":{"line":653,"column":1},"end":{"line":653,"column":1}},"children":[{"type":"text","value":"You might notice that one of these parts deals with repeated prescriptions. So in B. Harvest, you can have prescription that will periodically come back to a given stand - like long-term uneven-aged management or partial cuts -, or come from a second final cut - like the shelterwood method. Again, B. Harvest deals with all through the internal variables of LANDIS-II, in the RAM of the computer. However, ","position":{"start":{"line":653,"column":1},"end":{"line":653,"column":1}},"key":"i3rkmvfook"},{"type":"strong","position":{"start":{"line":653,"column":1},"end":{"line":653,"column":1}},"children":[{"type":"text","value":"the Python script that we run at every time step with Magic Harvest doesn’t have a permanent memory","position":{"start":{"line":653,"column":1},"end":{"line":653,"column":1}},"key":"tZvcBuCZuj"}],"key":"KNNXK8I0sp"},{"type":"text","value":"; when the script will finish for a given timestep, it will unload its variables. So, if you want to keep information saved for your script to re-load it at the next time step - for example, the list of stands that have repeated prescriptions so that you know which one to re-harvest periodically in the future - , ","position":{"start":{"line":653,"column":1},"end":{"line":653,"column":1}},"key":"SEuDH2TB3g"},{"type":"strong","position":{"start":{"line":653,"column":1},"end":{"line":653,"column":1}},"children":[{"type":"text","value":"you’ll have to save this in a file","position":{"start":{"line":653,"column":1},"end":{"line":653,"column":1}},"key":"iPxnZBI52o"}],"key":"GMD43Jx5ew"},{"type":"text","value":".","position":{"start":{"line":653,"column":1},"end":{"line":653,"column":1}},"key":"Q3mgm5cg35"}],"key":"yN04NjqrQ3"},{"type":"paragraph","position":{"start":{"line":655,"column":1},"end":{"line":655,"column":1}},"children":[{"type":"text","value":"Python makes that easy, with many choices : you can export Python objects - like Python dictionnaries - into a .json file, which is a popular format that is human-readable - meaning that you can open the file and read it yourself. You can also save it in “Pickle” format, which is not human readable, but which is made to save and load python objects easily. I recommand the pickle format for complex objects, and the Json format for simpler ones.","position":{"start":{"line":655,"column":1},"end":{"line":655,"column":1}},"key":"PjQwCQzrZO"}],"key":"gKAE5ieRxW"},{"type":"paragraph","position":{"start":{"line":657,"column":1},"end":{"line":657,"column":1}},"children":[{"type":"text","value":"Here is the code used later in the script (in the section where outputs are done) :","position":{"start":{"line":657,"column":1},"end":{"line":657,"column":1}},"key":"oRd0rmwaUB"}],"key":"YhaQZeCEmr"},{"type":"code","lang":"python","value":"# We save the pickle file with the data for the next repeated harvests\n# Wanted to use JSON, but doesn't work well with the complex dictionnaries I use.\n# WARNING : pickle is not human-readable. It is made to be read by a Python script.\nif repeatPrescriptionsDict!= \"noRepeatsForNow\":\n    with open('./input/disturbances/harvesting/tempMagicHarvest/repeatedPrescriptions.pickle', \"wb+\") as outfile:\n        pickle.dump(repeatPrescriptionsDict, outfile)","position":{"start":{"line":659,"column":1},"end":{"line":666,"column":1}},"key":"NspJ2lFzjs"},{"type":"paragraph","position":{"start":{"line":668,"column":1},"end":{"line":668,"column":1}},"children":[{"type":"text","value":"You can see that there are also a couple of lines to remove the files made by the Biomass Community extension, and which contain all of the vegetation data at the end of the previous timestep (and so, if Magic Harvest is the first disturbance extension to run, it’s also the state of the current time step before anything happens). These files are very heavy, so you might want to remove them once you’re done reading them.","position":{"start":{"line":668,"column":1},"end":{"line":668,"column":1}},"key":"FZJDh76dSF"}],"key":"xKSQKtObNf"},{"type":"code","lang":"python","value":"# Removing vegetation communities files if needed\nif not debug and removeCommunitiesFiles:\n    if os.path.exists(\"./output-community-\" + str(timestep- timestepLength) + \".img\"):\n        os.remove(\"./output-community-\" + str(timestep- timestepLength) + \".img\")\n    if os.path.exists(\"./community-input-file-\" + str(timestep- timestepLength) + \".csv\"):\n        os.remove(\"./community-input-file-\" + str(timestep- timestepLength) + \".csv\")\n    if os.path.exists((\"./community-input-file-\" + str(timestep- timestepLength) + \".csv\")[0:-3] + \"txt\"):\n        os.remove((\"./community-input-file-\" + str(timestep- timestepLength) + \".csv\")[0:-3] + \"txt\")","position":{"start":{"line":670,"column":1},"end":{"line":679,"column":1}},"key":"knDNLlpkau"},{"type":"paragraph","position":{"start":{"line":681,"column":1},"end":{"line":681,"column":1}},"children":[{"type":"text","value":"You can also see that there is a line preparing a two dimensional numpy array with the same dimensions as the management area map, but filled with zeroes. This is the array we will fill with the location of the pixels we want to harvest precisely, and that we will use to create the management raster that we will feedback to B. Harvest to control its harvesting, as I explained before.","position":{"start":{"line":681,"column":1},"end":{"line":681,"column":1}},"key":"SO4PR0Oua4"}],"key":"HWP3g2LkbX"},{"type":"code","lang":"python","value":"#%% PREPARING OTHER OBJECTS WE NEED\n\n# We prepare the empty management map that we will fill with the values of the pixels where we want to harvest.\nmanagementMap = np.zeros_like(getRasterData(\"../../sharedRasters/stands_v2.0.tif\"))","position":{"start":{"line":683,"column":1},"end":{"line":688,"column":1}},"key":"fof3HffOZj"},{"type":"heading","depth":3,"position":{"start":{"line":690,"column":1},"end":{"line":690,"column":1}},"children":[{"type":"text","value":"Making the management decisions","position":{"start":{"line":690,"column":1},"end":{"line":690,"column":1}},"key":"DhZaQ7wqAl"}],"identifier":"making-the-management-decisions","label":"Making the management decisions","html_id":"making-the-management-decisions","implicit":true,"key":"qcdUH7gYLe"},{"type":"paragraph","position":{"start":{"line":692,"column":1},"end":{"line":692,"column":1}},"children":[{"type":"text","value":"Now that everything is loaded, this is the part where you can do your management decisions. Here, as this script is a template, this part is empty. We’re going to do some exercises together afterward to explore what we can do here. But sky’s the limit. The only thing we have to do is to fill the array that will be used to output our management map, where each pixel contains the code of the prescription we want to apply in this pixel. The rest is up to our imagination.","position":{"start":{"line":692,"column":1},"end":{"line":692,"column":1}},"key":"IVg81dRd76"}],"key":"zA06H1PnrX"},{"type":"code","lang":"python","value":"#%% MAKING THE HARVEST DECISIONS\n\n# This is where you should write functions that will define where you want to harvest.\n# So, doing your repeated prescriptions, ranking the stands and then applying new prescriptions until you \n# reach a given target, etc., etc.\n","position":{"start":{"line":694,"column":1},"end":{"line":701,"column":1}},"key":"e6kMjROQCW"},{"type":"heading","depth":3,"position":{"start":{"line":704,"column":1},"end":{"line":704,"column":1}},"children":[{"type":"text","value":"Creating the outputs to control Biomass Harvest and others","position":{"start":{"line":704,"column":1},"end":{"line":704,"column":1}},"key":"zM3KiX9wrO"}],"identifier":"creating-the-outputs-to-control-biomass-harvest-and-others","label":"Creating the outputs to control Biomass Harvest and others","html_id":"creating-the-outputs-to-control-biomass-harvest-and-others","implicit":true,"key":"X4tzGdoYPc"},{"type":"paragraph","position":{"start":{"line":706,"column":1},"end":{"line":706,"column":1}},"children":[{"type":"text","value":"The final section is simply the creation of the outputs. We create an object containing information about the repeated prescription for the next; we create the raster map to give to B. Harvest to control its harvesting using the array we filled before; and we then edit the parameter text file of B. Harvest to add new prescriptions if we want to, indicate the name of this new management map we’re giving him, and also to write the implementation table to force him to harvest 100% of each pixel codes we have put in the map, as I’ve described before. The template also writes a couple of log files to help reading what happenned after the simulation.","position":{"start":{"line":706,"column":1},"end":{"line":706,"column":1}},"key":"aSvDoBRCA8"}],"key":"WL3YVoZd2c"},{"type":"code","lang":"python","value":"#%% OUTPUTS\n\n# This is where we create the files that we will give back to Biomass Harvest\n\nprint(\"Creating outputs...\")\n\n# We prepare the folder with temporary files\nif not os.path.exists(\"./input/disturbances/harvesting/tempMagicHarvest/\"):\n    os.mkdir(\"./input/disturbances/harvesting/tempMagicHarvest/\")\n\n# We save the pickle file with the data for the next repeated harvests\n# Wanted to use JSON, but doesn't work well with the complex dictionnaries I use.\n# WARNING : pickle is not human-readable. It is made to be read by a Python script.\nif repeatPrescriptionsDict!= \"noRepeatsForNow\":\n    with open('./input/disturbances/harvesting/tempMagicHarvest/repeatedPrescriptions.pickle', \"wb+\") as outfile:\n        pickle.dump(repeatPrescriptionsDict, outfile)\n\n# Create harvest maps\nprint(\"Magic harvest Python script : WRITING PRESCRIPTION MAP\")\nwriteNewRasterData(managementMap,\n                    \"../../sharedRasters/stands_v2.0.tif\",\n                    \"./input/disturbances/harvesting/tempMagicHarvest/prescriptions-\" + str(timestep) + \".tif\")\n\n# Create harvest txt file\n# We add to the txt file :\n# - The new plantation prescriptions\n# - The surface to harvest for each prescription ID / fake management areas to contrain harvesting\nwriteHarvestParameterFile(managementMap,\n                            \"/input/disturbances/harvesting/\",\n                            \"harvest_BAU_v2.0_TEMPLATE.txt\",\n                            \"harvest_BAU_v2.0.txt\",\n                            prescriptionParameters,\n                            \"./input/disturbances/harvesting/tempMagicHarvest/prescriptions-\" + str(timestep) + \".tif\",\n                            timestep)\n\n# Update table that gives the prescription names for each prescription ID\n# for easy identification in GIS softwares of the harvest output maps\nWriteTableOfPrescriptionsID(\"./input/disturbances/harvesting/tempMagicHarvest/prescriptionIDTable-\" + str(timestep) + \".csv\",\n                            prescriptionParameters)\n\n# We make a log of the harvested surfaces and volumes.\ncsvFileOutputPath = \"./output/magicHarvest/logMagicHarvest.csv\"\n\n\n# If first timestep, we create the file.\nif timestep == timestepLength:\n    if os.path.exists(csvFileOutputPath):\n        os.remove(csvFileOutputPath)\n    \n    # We make the output directories if they don't already exist\n    if not os.path.exists(os.path.dirname(csvFileOutputPath)):\n        os.makedirs(os.path.dirname(csvFileOutputPath))\n        \n    listOfHeaders = [\"Timestep\", \"Surface Harvested\"]\n    for target in volumeTargetDicts:\n        listOfHeaders.append(\"Volume \" + str(target) + \" harvested\")\n    \n    with open(csvFileOutputPath, 'w+', newline='') as file:\n        writer = csv.writer(file)\n        writer.writerow(listOfHeaders)\n\n# Then, we write the values\nnewRow = [str(timestep), str(np.count_nonzero(managementMap))]\nfor target in volumeTargetDicts:\n    newRow.append(str(volumeTargetCounterDict[target]))\nwith open(csvFileOutputPath, 'a', newline='') as file:\n    writer = csv.writer(file)\n    writer.writerow(newRow)","position":{"start":{"line":708,"column":1},"end":{"line":777,"column":1}},"key":"D6ZJNVWwWw"},{"type":"paragraph","position":{"start":{"line":779,"column":1},"end":{"line":779,"column":1}},"children":[{"type":"text","value":"And that’s it ! Once the script is over, Magic Harvest will force B. Harvest to re-load its parameters, and B. Harvest will then activate and harvest the pixels in the way we told him.","position":{"start":{"line":779,"column":1},"end":{"line":779,"column":1}},"key":"uo1XmAnTe0"}],"key":"UawBbjv0i1"},{"type":"paragraph","position":{"start":{"line":781,"column":1},"end":{"line":781,"column":1}},"children":[{"type":"text","value":"Of course, there are many functions that you could add to the template; for example, functions to read the rasters from other disturbances extensions (like fire and insect epidemics) to then know where to do salvage logging. Don’t feel restricted by what I’ve described here. In fact, we’re now going to finish by making you use your imagination a bit !","position":{"start":{"line":781,"column":1},"end":{"line":781,"column":1}},"key":"ptf1aLEXKU"}],"key":"OQwKBM0yor"},{"type":"heading","depth":2,"position":{"start":{"line":783,"column":1},"end":{"line":783,"column":1}},"children":[{"type":"text","value":"Conclusion about using Magic Harvest in practice","position":{"start":{"line":783,"column":1},"end":{"line":783,"column":1}},"key":"R3DRRuV898"}],"identifier":"conclusion-about-using-magic-harvest-in-practice","label":"Conclusion about using Magic Harvest in practice","html_id":"conclusion-about-using-magic-harvest-in-practice","implicit":true,"key":"Y9RnUF0Fa9"},{"type":"paragraph","position":{"start":{"line":785,"column":1},"end":{"line":785,"column":1}},"children":[{"type":"text","value":"You should now have a pretty good idea of how using Magic Harvest works in term of using files; or at least inspiration to do your own script and run them in LANDIS-II.","position":{"start":{"line":785,"column":1},"end":{"line":785,"column":1}},"key":"jCE0TehCHt"}],"key":"IrhaX5fCZM"},{"type":"paragraph","position":{"start":{"line":787,"column":1},"end":{"line":787,"column":1}},"children":[{"type":"text","value":"We’re going to finish by doing a couple of exercises to train your imagination to write some algorithms to make your management decisions through a script.","position":{"start":{"line":787,"column":1},"end":{"line":787,"column":1}},"key":"USDJgItoOr"}],"key":"gWHt54pHSW"}],"key":"Vv8pHFV3BV"}],"key":"SVpXZzDzsN"},"references":{"cite":{"order":[],"data":{}}},"footer":{"navigation":{"prev":{"title":"How Magic Harvest Works","url":"/howmagicharvestworks","group":"Introduction"},"next":{"title":"Exercices","url":"/exercises","group":"Introduction"}}},"domain":"http://localhost:3002"},"project":{"id":"a9d9bd1a-fce3-4a75-94db-95be0178f5ce","thumbnail":"https://klemet.github.io/Workshop-MagicHarvest/build/c46244155f82f0a2188b900fb12670c3.svg","exports":[],"bibliography":[],"title":"Introduction","index":"introduction","pages":[{"slug":"howmagicharvestworks","title":"How Magic Harvest Works","description":"","date":"","thumbnail":"https://klemet.github.io/Workshop-MagicHarvest/build/c46244155f82f0a2188b900fb12670c3.svg","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":1},{"slug":"lookingatthingsinpractice","title":"Using Magic Harvest in practice","description":"","date":"","thumbnail":"https://klemet.github.io/Workshop-MagicHarvest/build/c46244155f82f0a2188b900fb12670c3.svg","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":1},{"slug":"exercises","title":"Exercices","description":"","date":"","thumbnail":"https://klemet.github.io/Workshop-MagicHarvest/build/c46244155f82f0a2188b900fb12670c3.svg","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":1},{"slug":"conclusion","title":"Conclusion","description":"","date":"","thumbnail":"https://klemet.github.io/Workshop-MagicHarvest/build/c46244155f82f0a2188b900fb12670c3.svg","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":1}]}}},"actionData":null,"errors":null},"future":{"unstable_dev":false,"unstable_postcss":false,"unstable_tailwind":false,"v2_errorBoundary":true,"v2_headers":true,"v2_meta":true,"v2_normalizeFormMethod":true,"v2_routeConvention":true}};</script><script type="module" async="">import "https://klemet.github.io/Workshop-MagicHarvest/build/manifest-B2B2E6A5.js";
import * as route0 from "https://klemet.github.io/Workshop-MagicHarvest/build/root-IB5726YR.js";
import * as route1 from "https://klemet.github.io/Workshop-MagicHarvest/build/routes/$-LXLHKVOR.js";
window.__remixRouteModules = {"root":route0,"routes/$":route1};

import("https://klemet.github.io/Workshop-MagicHarvest/build/entry.client-UNPC4GT3.js");</script></body></html>