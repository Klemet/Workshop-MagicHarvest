{"version":"1","records":[{"hierarchy":{"lvl1":"Introduction"},"type":"lvl1","url":"/introduction","position":0},{"hierarchy":{"lvl1":"Introduction"},"content":"Authors: Clément Hardy1 Affiliations: 1Université du Québec en Outaouais (UQO)\\\n\n\n\nThis small website contains a workshop to help you use the \n\nMagic Harvest extension for the \n\nLANDIS-II forest landscape model. It’s simply an implementation of the powerpoint presentation I did in the summer of 2025 at the University of Toronto. You’ll have both the slides and the text of the slides in a readable format.","type":"content","url":"/introduction","position":1},{"hierarchy":{"lvl1":"Introduction","lvl2":"What is Magic Harvest ?"},"type":"lvl2","url":"/introduction#what-is-magic-harvest","position":2},{"hierarchy":{"lvl1":"Introduction","lvl2":"What is Magic Harvest ?"},"content":"Magic Harvest is a small extension that I develloped during my PhD thesis. My work required me to compare the effect of several forest management scenarios in LANDIS-II; but at the time, LANDIS-II lacked several important features that I needed to implement forest management in the model. I created Magic Harvest in order to solve the issue.\n\n\n\nThe Magic Harvest extension is both simple and complicated. Simple, because its functionning can be summarized in two sentences : it’s a companion extension for Biomass Harvest (the main harvest extension for LANDIS-II; the other ones are almost never used) who’s goal is to run before Biomass Harvest. When running, it will simply launch a custom command defined by the user - for example an R or Python script - and will then force Biomass Harvest to re-load its parameters. That’s it.\n\nThe complex part is understanding the consequences of this and learning to play with it. The consequences is that we can control what Biomass Harvest does at different degrees : complete and total control, or still letting Biomass Harvest do some choices based on its own algorithm. Learning to play with Magic Harvest mostly means learning to write scripts that will do what you want to do.","type":"content","url":"/introduction#what-is-magic-harvest","position":3},{"hierarchy":{"lvl1":"Introduction","lvl2":"Plan of the workshop"},"type":"lvl2","url":"/introduction#plan-of-the-workshop","position":4},{"hierarchy":{"lvl1":"Introduction","lvl2":"Plan of the workshop"},"content":"\n\nSo today, we’re going to see :\n\nHow Magic Harvest works in a bit more details\n\nSome visual examples of how much control we can achieve\n\nTaking a look at a Python script I’ve made to use Magic Harvest\n\nAnd then do a couple of exercises together to get familliar with how to do what you want to do with it\n\nWe are not going to run Magic Harvest; you have test files accessible on the repository, and it’s very easy to run if you know how to run LANDIS-II. As we’re going to see, the parameter file is very small. Today, I prefer that we focus on understanding the model and understanding what you can do with it.","type":"content","url":"/introduction#plan-of-the-workshop","position":5},{"hierarchy":{"lvl1":"Introduction","lvl2":"Credits"},"type":"lvl2","url":"/introduction#credits","position":6},{"hierarchy":{"lvl1":"Introduction","lvl2":"Credits"},"content":"Visuals for this presentation come from :\n\nStoryset on Freepik (characters of Magic Harvest and Biomass Harvest; original images from Storyset have been edited)\n\nDifferent icons from \n\nIconify (repository of many open-source icon sets).","type":"content","url":"/introduction#credits","position":7},{"hierarchy":{"lvl1":"How Magic Harvest Works"},"type":"lvl1","url":"/howmagicharvestworks","position":0},{"hierarchy":{"lvl1":"How Magic Harvest Works"},"content":"Authors: Clément Hardy1 Affiliations: 1Université du Québec en Outaouais (UQO)\\\n\n","type":"content","url":"/howmagicharvestworks","position":1},{"hierarchy":{"lvl1":"How Magic Harvest Works","lvl2":"A metaphor : Magic and B. Harvest"},"type":"lvl2","url":"/howmagicharvestworks#a-metaphor-magic-and-b-harvest","position":2},{"hierarchy":{"lvl1":"How Magic Harvest Works","lvl2":"A metaphor : Magic and B. Harvest"},"content":"\n\nFirst, and for the rest of this workshop, I’m going to use a metaphor to represent Magic Harvest and Biomass Harvest : Biomass Harvest, being the Biomass Harvest extension of LANDIS-II, is a forester. We’ll call them “B. Harvest” from now on. B. Harvest being a forester, their main skill is in harvesting trees, and they have all of the tools for that. They can do some forest management decisions, but it’s not their main strength. When they do forest management decisions, they has a pretty simply algorithm that they learned from school.\n\nMagic Harvest, that we’ll just call “Magic” for short, is a forest engineer. They don’t have the tools to cut trees at all. They can’t cut trees ! That why they have to rely on B. Harvest to do it. But they’re a genius at forest planning : unlike B. Harvest, Magic they do anything ! They can use any type of models, do any kind of instruction.\n\nAs such, B. Harvest can work alone to do the management decisions and the harvesting. Magic has to work with B. Harvest because they cannot harvest trees by themselves; but they can really help B. Harvest do better at management decisions.","type":"content","url":"/howmagicharvestworks#a-metaphor-magic-and-b-harvest","position":3},{"hierarchy":{"lvl1":"How Magic Harvest Works","lvl2":"What happens when B. Harvest works alone ?"},"type":"lvl2","url":"/howmagicharvestworks#what-happens-when-b-harvest-works-alone","position":4},{"hierarchy":{"lvl1":"How Magic Harvest Works","lvl2":"What happens when B. Harvest works alone ?"},"content":"\n\nSo let’s see what happens when B. Harvest works alone. This is basically a visual summary of what you will find in the \n\nuser guide of Biomass Harvest. However, this is important so that we can understand how he is going to work with Magic afterwards.\n\nB. Harvest has a simple algorithm based on three things : a set of maps showing the management areas and the stand in the landscape; a list of harvest prescriptions and the way to choose the stands that they will harvest with this prescription; and an implementation table giving the % of management areas that must be harvested with a given prescription. The rasters are given as raster files; the prescription instruction and harvest implementation table are inside a single parameter text file.\n\n\n\nDuring a time step of LANDIS-II, when it’s time for B. Harvest to work, they’re going to look at the implementation table line by line. For each line, they’re going to look at the management area concerned; they’re going to rank the stands according to the ranking criteria that goes with the prescription; and then, they’re going to harvest stands until they reach the % of surface to harvest.\n\nAnd that’s it ! There are other nuances that B. Harvest can do, like the fact that they can use different ranking methods, that they can make different patterns of cuts size, or that they can plant species; I’m not going to good deeper here, and will stay simple.\n\n\n\nOne thing to remember is that the instructions of B. Harvest cannot change once the simulation has started. They cannot be dyamically changed, and its limited algorithm means that there is a lot that B. Harvest cannot do. It cannot react to disturbances and do salvage logging; it cannot make complex planting based on the species present in a given stand. It cannot adapt to changes in supply and demand of wood. It will just implement the same implementation table during the entire simulation.","type":"content","url":"/howmagicharvestworks#what-happens-when-b-harvest-works-alone","position":5},{"hierarchy":{"lvl1":"How Magic Harvest Works","lvl2":"When Magic and B. Harvest work together"},"type":"lvl2","url":"/howmagicharvestworks#when-magic-and-b-harvest-work-together","position":6},{"hierarchy":{"lvl1":"How Magic Harvest Works","lvl2":"When Magic and B. Harvest work together"},"content":"\n\nNow, what goes on when Magic and B. Harvest are working together ? First of all, you gotta make sure that Magic runs before B. Harvest at every timestep. This is done by specifying Magic right before B. Harvest in the disturbance extensions of your scenario file, and making sure that the disturbance extension order is not random.\n\n\n\nDuring a time step, Magic will run before B. Harvest. As I said before, Magic will simply run a custom command defined by the user, and then re-load the parameters of B. Harvest by giving him new parameter files that the command has edited. This makes it possible to have management decisions that are dynamic, since Magic can take into account the content of the landscape before editing the files of B. Harvest.\n\n\n\nRemember that the command launched by Magic can be anything : an R script, a Python script, another model, and so on. It’s very easy to edit the text files and raster maps needed by B. Harvest with this.\n\nThe key thing to remember is thus this : every management decision done by Magic will be done through your custom command, wherever it is a script or another program. By default, Magic harvest does not have any algorithm to make decisions. YOU have to create it from A to Z and run it through the custom command. Luckily, I’ve already done a lot of scripts that I will give you and that will do most of the work for you. We will see that afterward.\n\n\n\nThe way that the custom command is launched is through the Magic Harvest parameter text file. It’s a very simple text file that is the only parameter file that Magic Harvest requires : the rest will depend on the command that you want to launch. The file just contains the time step frequency at which Magic Harvest should be run, and indications about the command you want to launch.\n\nA cool thing is that you can add “arguments” to your command, which can give additional information to the script you’re trying to launch. Of course, you’ll have to indicate the path to your script; but I’ve coded a {timestep} argument you can pass that will give the current timestep of LANDIS-II to your command. You’ll have to gather this time step argument in your script or model. I’ll show you afterward how this is done in Python.\n\n\n\nAnother important comment here : as we’re launching a custom command, that means that the program launched by the command - wherever R, Python or anything else - must be present on the computer you’re running the simulation on, and needs to be accessible to a command prompt. Some people have had issue with that because on windows, the Python or R programs are not always accessible through the command prompt.\n\nTo be sure, just open a command prompt, type “Python” or “Rscript”; and if these commands are not recognized, just look online on how to make sure that they are available in a command prompt.\n\n\n\nSo that also means that you will need, on your computer : LANDIS-II, the program you’re running, but also any packages your script might use, like R or Python packages. The fact that you’re depending on a complex environment with these different dependancies means that it can be near impossible for someone in the future to replicate your simulation.\n\n\n\nLuckily, there is a clear solution for that : use \n\nDocker. Docker allows you to create a virtual machine that can be run on any computer, which is define by a text file that creates your environment. This will allow you to keep the environment where you run LANDIS-II and your scripts and all separate from the rest of your computer (and so less likely to be corrupted or edited), and will allow anybody in the future to replicate your results by simply re-creating your Docker virtual machine using the text file you used to create yours.\n\nCheck the official LANDIS-II repository \n\nTool​-Docker​-Apptainer to get Docker images with LANDIS-II on them, and all of the instructions you will need to run them. If you have questions, ask me after this workshop !\n\n\n\nSo now our command is launched, which will edit the files of B. Harvest with management instructions - because if you don’t do that, then there’s no point in using Magic Harvest after all. Now, by editing the files of B. Harvest, Magic can have different levels of controls other B. Harvest, that will leave different degrees of decisions to B. Harvest. This is due to the fact that we can play with the three categories of input of B. Harvest to more or less constrain what B. Harvest will do.\n\n\n\nFor example, we can simply edit existing harvest prescriptions or change a management area with Magic, and pass this to B. Harvest. In that case, B. Harvest will still try to implement its implementation table in the management areas. As such, it will still be the algorithm of B. Harvest that will decide what stands or pixels will be harvested through its ranking algorithm, and so on.\n\n\n\nBut we can completly bypass the decision algorithm of B. Harvest by indicating precisely what stands or pixels we want to harvest. To do this, we ask Magic to create a map where each pixel to harvest with a certain prescription is associated with a given code (e.g. 2 for clearcutting, 3 for clearcutting + planting of balsam fir, 4 for partial cutting, etc.). We will of course use a custom Python or R script to create this map; everything is done via scripting in Magic Harvest.\n\nThen, we can give this map to B. Harvest as both his Management area map and his stand map. I know this can seem confusing; but by stay with me for a moment. So what B. Harvest will see is that all pixels with the same number are part of the same big management area AND the same big stand. And then, we simply have to edit the implementation table of B. Harvest to tell him that 100% (so, all) of the pixels with a given code must be harvested with the prescription that corresponds to the code. We do that by specifiying the codes we made as the management areas.\n\nSo what B. Harvest reads is “harvest all pixels of management area 1 at this timestep with this prescription”. And since all of these pixels are in the same big stand according to him (because we’re using the same map for management areas and stands), then he is simply going to harvest them all. So in essence, it’s like Magic tells B. Harvest exactly what to do, and B. Harvest takes absolutly no decision anymore. By following its usual algorithm, it’s simply going to harvest all of the pixels that Magic has indicated to him without asking any questions. Oh, and as we’ll see later, we can also create whole new prescriptions dynamically if we need to !\n\n\n\nI know that this part might be the most confusing. In essence, what we’re doing is that we are “hacking” B. Harvest’s algorithm by feeding it management maps that are not realistic, but that will constrain him to do exactly what we want. This is, of course, not a very “elegant” solution, and it’s not super easy to explain in papers. But it does work, and it is completely scripted and replicable, which is the most important part.\n\n\n\nAnd even though it is not very elegant, it allows us to do something incredible : we can mix the decades of experiences behind the LANDIS-II model and its extensions with the possibility to freely design our forest management decisional algorithms from A to Z, which allow us to explore any question we want related to forest management.\n\nWe could run the Woodstock model they use in forestry to decide where to harvest and then pass it to B. Harvest; we can make complex forms of planting that react to the species already present in a cell, like I’ve done in my thesis; we can even create a representation of network in the landscape in our script - for example, the Functional Complex Network of Christian Messier - and then make management decisions based on that. This is, to my knowledge, something quite novel in forest ecology, and really amazing.","type":"content","url":"/howmagicharvestworks#when-magic-and-b-harvest-work-together","position":7},{"hierarchy":{"lvl1":"How Magic Harvest Works","lvl2":"Conclusion about how Magic Harvest works"},"type":"lvl2","url":"/howmagicharvestworks#conclusion-about-how-magic-harvest-works","position":8},{"hierarchy":{"lvl1":"How Magic Harvest Works","lvl2":"Conclusion about how Magic Harvest works"},"content":"As you’ve seen, Magic Harvest can take control of Biomass Harvest in different ways : from taking some of the decisions (e.g. adding new management areas dynamically, but letting B. Harvest choose what stands are harvested in these new areas) to complete control (telling Biomass Harvest the exact pixels that will be harvested).\n\nSince everything we do in Magic Harvest will come from a script or another program than LANDIS-II, this opens up an enormous amount of possibility. The limit is in what you can code, or what your other programs can do. But the big trade-off is that the more control you want to take, the more things you will have to do by yourself. For example, if you want to manage repeated prescriptions throughout time steps using Magic Harvest (and take these decisions away from Biomass Harvest), you will have to find a way to keep track of these outside of LANDIS-II. You’ll also need to find ways to make the internal data from LANDIS-II (which is in the RAM of the computer during the simulation run of LANDIS-II) readable to your program or to your script. Most of the time, this is done by reading the latest output rasters for the current rasters (since what’s in the RAM is not accessible to programs other than LANDIS-II).\n\nWe’re now going to explore these more technical aspects, and I’ll show you a template of a Python Script that has pre-built functions to take complete control of Biomass Harvest’s decisions down to the pixel level.","type":"content","url":"/howmagicharvestworks#conclusion-about-how-magic-harvest-works","position":9},{"hierarchy":{"lvl1":"Using Magic Harvest in practice"},"type":"lvl1","url":"/lookingatthingsinpractice","position":0},{"hierarchy":{"lvl1":"Using Magic Harvest in practice"},"content":"Authors: Clément Hardy1 Affiliations: 1Université du Québec en Outaouais (UQO)\\\n\n","type":"content","url":"/lookingatthingsinpractice","position":1},{"hierarchy":{"lvl1":"Using Magic Harvest in practice","lvl2":"Getting on the field !"},"type":"lvl2","url":"/lookingatthingsinpractice#getting-on-the-field","position":2},{"hierarchy":{"lvl1":"Using Magic Harvest in practice","lvl2":"Getting on the field !"},"content":"\n\nHere, we’re going to see the more technical details of using Magic Harvest :\n\nHow to access the state of the LANDIS-II landscape in a Python or R script run with Magic Harvest ?\n\nHow to edit the parameter files of Biomass Harvest to control harvesting ?\n\nEtc.","type":"content","url":"/lookingatthingsinpractice#getting-on-the-field","position":3},{"hierarchy":{"lvl1":"Using Magic Harvest in practice","lvl2":"Looking at some example files for a simple simulation"},"type":"lvl2","url":"/lookingatthingsinpractice#looking-at-some-example-files-for-a-simple-simulation","position":4},{"hierarchy":{"lvl1":"Using Magic Harvest in practice","lvl2":"Looking at some example files for a simple simulation"},"content":"\n\nFirst of all, I’m going to show you some screenshots of a test scenario with Magic Harvest, with \n\nthe test files that are on the repository of Magic Harvest. Just so that you have a visual idea of what it looks like in action.\n\nHere is the scenario file that we have quickly seen before; as you see, Magic Harvest is indicated before B. Harvest, and the disturbance order is not random. The path points to the parameter text file of magic harvest. Here is the magic harvest parameter file, that we also have seen before; it’s very simple, and launches a Python script that simply switches the name of files to activate a different B. Harvest parameter text files.\n\n\n\nHere is the Python script launched by Magic Harvest everytime it runs. You see, it’s very simple. It simply renames files to switch between two sets of input files for B. Harvest. This is one of the simplest ways you can influence B. Harvest; you don’t even edit files, you just switch them.\n\n\n\nAnd finally, here is the log of LANDIS-II when it is running. As you see, Magic Harvest writes in the log when it activates, when it’s done running, and when it re-loads the parameters of B. Harvest. We can even see the “print” statements that come from the Python script, and which indicate what the script is doing ! This is great for debugging. If B. Harvest is not installed or used in the simulation, Magic Harvest will warn you of it.\n\nCaution\n\nThe print statements from your R or Python script will not be recorded in the LANDIS-II log text file that LANDIS-II generates during the simulation. But they will be seen in your console.","type":"content","url":"/lookingatthingsinpractice#looking-at-some-example-files-for-a-simple-simulation","position":5},{"hierarchy":{"lvl1":"Using Magic Harvest in practice","lvl2":"Taking a look at a Python script template"},"type":"lvl2","url":"/lookingatthingsinpractice#taking-a-look-at-a-python-script-template","position":6},{"hierarchy":{"lvl1":"Using Magic Harvest in practice","lvl2":"Taking a look at a Python script template"},"content":"\n\nNow, I’m going to show you a “template” of a Python script I’ve been using in my PhD thesis and my post-doctoral work. This template reads the state of the landscape and other things, and then writes some files to give to B. Harvest. The rest (the management decisions based on the state of the landscape) are up to you to write. We’ll use this template as a base for the following exercice. \n\nYou can download the full file here.\n\nSo first off, a warning : the template I’m about to show you is complex, even though I have removed any management decisions. You have to understand that I’ve spent years working on this script through two chapters of my thesis, and then my post-doc work. It’s full of functions made to do things quickly and in an optimized way. It’s also made to adapt to the pretty complex forms of management decision I’ve been making. So what I am about to show you is going to be overwelming. As such, I propose that you to not try to understand or read or remember everything. In the future, you might use this template for your own work; it is very heavily commented, and you will have the time to understand it piece by piece. Here, I simply want to give you a glimpse under the hood to show you what the engine can look like.\n\nYou might also feel like it’s not normal for this methodology to get this complicated; that Magic Harvest is nice, but that this is just too much work and complexity. It’s something I have often felt when working on this. But here, we are working a trade-off : Magic Harvest allow us to become free from the restrictive and pre-defined algorithms of LANDIS-II and do whatever we want, which is essential to our research; but the trade-off is that we have to write the code for that, and it gets complex; just like the code inside LANDIS-II is. It’s just that usually, we don’t touch the LANDIS-II code as users. Here, we have to code everything. That’s the trade-off.\n\nWe could, of course, code a whole new harvest extension for LANDIS-II instead of using a script like this; but this become restrictive again because you have to deal with the complex building process of extensions in the C# langage that LANDIS-II uses, you have to maintain them, and then future users become restricted by your algorithm. By using R or Python scripts, we can use simpler programming langages that most ecologist know to some degree, and we can share our scripts easily, and they can be re-used easily. So, no solution is perfect; but while this one is complex, it works realiably and gives us a high level of control.\n\nSo, ready ? Let’s dig in.","type":"content","url":"/lookingatthingsinpractice#taking-a-look-at-a-python-script-template","position":7},{"hierarchy":{"lvl1":"Using Magic Harvest in practice","lvl3":"Defining functions for everything","lvl2":"Taking a look at a Python script template"},"type":"lvl3","url":"/lookingatthingsinpractice#defining-functions-for-everything","position":8},{"hierarchy":{"lvl1":"Using Magic Harvest in practice","lvl3":"Defining functions for everything","lvl2":"Taking a look at a Python script template"},"content":"The beginning of this template is simply a section where a lot of functions are defined so that we can use them afterwards. I really advise you define functions like this. It makes the rest of the code much clearer. In Python, it is really easy to describe each function you’re writting, in particular its inputs and outputs, via a “docstring”, a string of text that documents the function. Modern text editors allow you to write it quickly. AI can write it for you too.\n\nHere is an example in the script :def readingStandsCoordinates(standRasterDataAll, disableTQDM):\n    '''Reads the stands map to get the coordinates of each pixel in a stand.\n    Returns a dictionnary giving the coordinates for each pixel for a given\n    stand ID. Locations are in (row, column) tuple format, as necessary to\n    access a value in a numpy array made from a raster by Rasterio.\n    standRasterDataAll must be a numpy array contained the data from your raster map.'''\n    print(\"Reading stands coordinates...\")\n    standCoordinatesDict = dict()\n    uniqueAllStandsID = np.unique(standRasterDataAll).tolist()\n    # id 0 for stands = no forests\n    uniqueAllStandsID.remove(0)\n    for standID in tqdm(uniqueAllStandsID, disable = disableTQDM):\n        # print(standID)\n        standCoordinatesDict[standID] = list()\n    for x in tqdm(range(standRasterDataAll.shape[0]), disable = disableTQDM):\n        for y in range(standRasterDataAll.shape[1]):\n            standID = standRasterDataAll[(x, y)]\n            if standID != 0:\n                standCoordinatesDict[standID].append((x, y))\n    return(standCoordinatesDict)\n\nThere’s a lot of functions here. The first ones are used to easily read and write raster map data. When we read raster map data, we put it in a “numpy” array - numpy being a very famous Python package that allows for extremely efficient vectorial, matricial, or generally multi-dimensional array computation. So we put the values of the raster in a 2-dimensional array.def getRasterData(path):\n    raster = gdal.Open(path)\n    rasterData = raster.GetRasterBand(1)\n    rasterData = rasterData.ReadAsArray()\n    return(np.array(rasterData))\n\t\ndef getRasterDataAsList(path):\n    return(getRasterData(path).tolist())\n\ndef writeNewRasterData(rasterDataArray, pathOfTemplateRaster, pathOfOutput):\n    # Saves a raster in int16 with a nodata value of 0\n    # Inspired from https://gis.stackexchange.com/questions/164853/reading-modifying-and-writing-a-geotiff-with-gdal-in-python\n    # Loading template raster\n    template = gdal.Open(pathOfTemplateRaster)\n    driver = gdal.GetDriverByName(\"GTiff\")\n    [rows, cols] = template.GetRasterBand(1).ReadAsArray().shape\n    outputRaster = driver.Create(pathOfOutput, cols, rows, 1, gdal.GDT_Int16)\n    outputRaster.SetGeoTransform(template.GetGeoTransform())##sets same geotransform as input\n    outputRaster.SetProjection(template.GetProjection())##sets same projection as input\n    outputRaster.GetRasterBand(1).WriteArray(rasterDataArray)\n    outputRaster.GetRasterBand(1).SetNoDataValue(0)##if you want these values transparent\n    outputRaster.FlushCache() ##saves to disk!!\n    outputRaster = None\n    \ndef writeNewRasterDataFloat32(rasterDataArray, pathOfTemplateRaster, pathOfOutput):\n    # Saves a raster in Float32 with a nodata value of 0.0\n    # Inspired from https://gis.stackexchange.com/questions/164853/reading-modifying-and-writing-a-geotiff-with-gdal-in-python\n    # Loading template raster\n    template = gdal.Open(pathOfTemplateRaster)\n    driver = gdal.GetDriverByName(\"GTiff\")\n    [rows, cols] = template.GetRasterBand(1).ReadAsArray().shape\n    outputRaster = driver.Create(pathOfOutput, cols, rows, 1, gdal.GDT_Float32)\n    outputRaster.SetGeoTransform(template.GetGeoTransform())##sets same geotransform as input\n    outputRaster.SetProjection(template.GetProjection())##sets same projection as input\n    outputRaster.GetRasterBand(1).WriteArray(rasterDataArray)\n    outputRaster.GetRasterBand(1).SetNoDataValue(0)##if you want these values transparent\n    outputRaster.FlushCache() ##saves to disk!!\n    outputRaster = None\n\ndef writeExistingRasterData(rasterDataArray, pathOfRasterToEdit):\n    # Edits the data of an existing raster\n    rasterToEdit = gdal.Open(pathOfRasterToEdit, gdal.GF_Write)\n    rasterToEdit.GetRasterBand(1).WriteArray(rasterDataArray)\n    rasterToEdit.FlushCache() ##saves to disk!!\n    rasterToEdit = None\n\nThen, we have functions that read the state and structure of the landscape in LANDIS-II. To do that, we use input and output raster maps and files from LANDIS-II that will be in our simulation folder. Of course, when LANDIS-II runs, it has its own internal variables that contain the information on the landscape; but sadly, we cannot access these. These variables are contained in the RAM of your computer, and they are only accessible to the program. Since the script we are using is outside LANDIS-II - it’s run through Python, not LANDIS-II -, then we cannot access these internal variables of LANDIS-II.\n\nBut that’s fine, because we can use output extensions and some input files of LANDIS-II to get everything we need.\n\nFor example, to get the forest stands in the landscape, we can read the map of forest stands - the one that is usually given to B. Harvest.def readingStandsCoordinates(standRasterDataAll, disableTQDM):\n    '''Reads the stands map to get the coordinates of each pixel in a stand.\n    Returns a dictionnary giving the coordinates for each pixel for a given\n    stand ID. Locations are in (row, column) tuple format, as necessary to\n    access a value in a numpy array made from a raster by Rasterio.\n    standRasterDataAll must be a numpy array contained the data from your raster map.'''\n    print(\"Reading stands coordinates...\")\n    standCoordinatesDict = dict()\n    uniqueAllStandsID = np.unique(standRasterDataAll).tolist()\n    # id 0 for stands = no forests\n    uniqueAllStandsID.remove(0)\n    for standID in tqdm(uniqueAllStandsID, disable = disableTQDM):\n        # print(standID)\n        standCoordinatesDict[standID] = list()\n    for x in tqdm(range(standRasterDataAll.shape[0]), disable = disableTQDM):\n        for y in range(standRasterDataAll.shape[1]):\n            standID = standRasterDataAll[(x, y)]\n            if standID != 0:\n                standCoordinatesDict[standID].append((x, y))\n    return(standCoordinatesDict)\n\nFor informations about the harvest prescriptions, we can simple “parse” the B. Harvest parameters text file. This is a bit more tricky, but the function is already there, and allows us to put all informations into a Python dictionnary. The dictionnaries of Python is an object that I love very much and use very often : it simply associate an object (e.g. a number, a sentence or a word, or any other object) with another. Here, by reading the harvest parameter text file, I created a big dictionnary that contains the information and rules about each prescription in there. This can be useful, for example, to estimate how much biomass these prescription will harvest in the cells. Making this estimation can be used to know if we have reached the targets we have for the current timestep.def harvestParameterFileParser(path):\n    \"\"\"\n    Parses the biomass harvest parameter file at the given path.\n    Returns a dictionnary with the needed parameters.\n    \n    WARNING : To read the harvest file properly, make sure to :\n    - Not use relative number of cohorts harvested for a given species, like\n      \"1/2\" or \"1/3\". Since this script is made to be used with biomass harvest,\n      use things like \"11-999(50%)\" to harvest half of the biomass of each cohort.\n    - Make sure the biomass percentages are not separated from their respective\n      age class, meaning write \"11-999(50%)\" rather than \"11-999 (50%)\"\n    \"\"\"\n    print(\"Reading harvest parameter file...\")\n    \n    dictToReturn = dict()\n    \n    # WARNING : Here is the list of species I use. Replace it with your own species\n    # codes that you use in LANDIS-II !\n    speciesList = [\"ABIE.BAL\",\"ACER.RUB\",\"ACER.SAH\",\"BETU.ALL\",\"BETU.PAP\",\n                   \"FAGU.GRA\",\"LARI.LAR\",\"LARI.HYB\",\"PICE.GLA\",\"PICE.MAR\",\n                   \"PICE.RUB\",\"PINU.BAN\",\"PINU.RES\",\"PINU.STR\",\"POPU.TRE\",\n                   \"POPU.HYB\",\"QUER.RUB\",\"THUJ.SPP.ALL\",\"TSUG.CAN\"]\n    \n    with open(path, 'r') as file:\n        prescriptionSelected = \"none\"\n        prescriptionID = 1 # We start at 1 because the ID is for the raster;\n        # 0 = not forest, 1 = forest not harvested, and then it's the prescriptions.\n        for line in file:\n            # print(line)\n            # We start by recording the lines if we're reading a prescription\n            if prescriptionSelected != \"none\" and \"Prescription \" not in line:\n                dictToReturn[prescriptionSelected][\"FullString\"].append(line)\n            if \">>-------------\" in line:\n                prescriptionSelected = \"none\"\n                \n            # We get the timestep used by the extension\n            if \"Timestep\" in line:\n                timestepLength = int(splitLineAndRemoveTabsAndSpaces(line)[1])\n            # If we find a new prescription, we initialize everything needed\n            if \"Prescription \" in line:\n                prescriptionSelected = line[len(\"Prescription \"):-1] #-1 removes the \\n character at the end of each line\n                if prescriptionSelected not in dictToReturn:\n                    dictToReturn[prescriptionSelected] = dict()\n                    dictToReturn[prescriptionSelected][\"Planting\"] = \"none\"\n                    dictToReturn[prescriptionSelected][\"RepeatMode\"] = \"none\"\n                    dictToReturn[prescriptionSelected][\"MaximumStandAge\"] = 999\n                    dictToReturn[prescriptionSelected][\"MinimumStandAge\"] = 0\n                    dictToReturn[prescriptionSelected][\"Commercial\"] = True # Does it generate merchantable wood ?\n                    dictToReturn[prescriptionSelected][\"FullString\"] = [line] # We keep all the lines of the prescription to be able to copy it to make different plantings\n                    prescriptionID += 1\n                    dictToReturn[\"_MaxPrescriptionID\"] = prescriptionID # Special counter used to create new planting prescriptions later\n                    dictToReturn[prescriptionSelected][\"PrescriptionID\"] = prescriptionID\n                singleRepeat = False\n            \n            # Else, we register the parameters of the prescription\n            elif \"MaximumAge\" in line:\n                maximumAge = splitLineAndRemoveTabsAndSpaces(line)[1]\n                dictToReturn[prescriptionSelected][\"MaximumStandAge\"] = int(maximumAge)\n            elif \"MinimumAge\" in line:\n                minimumAge = splitLineAndRemoveTabsAndSpaces(line)[1]\n                dictToReturn[prescriptionSelected][\"MinimumStandAge\"] = int(minimumAge)\n            elif \"SiteSelection\" in line:\n                # The line contains 2 words + the two numerical values we want\n                # We remove everything we don't need to get the two values\n                splittedLine = splitLineAndRemoveTabsAndSpaces(line)\n                # print(splittedLine)\n                dictToReturn[prescriptionSelected][\"HarvestPropagation\"] = [float(splittedLine[2]), float(splittedLine[3])]\n            elif \"CohortsRemoved\" in line and not singleRepeat:\n                dictToReturn[prescriptionSelected][\"CohortRemoved\"] = dict()\n            elif \"Planting\" in line:\n                plantingString = splitLineAndRemoveTabsAndSpaces(line)[1]\n                dictToReturn[prescriptionSelected][\"Planting\"] = plantingString\n            elif \"Commercial\" in line and \"FALSE\" in line.upper():\n                dictToReturn[prescriptionSelected][\"Commercial\"] = False\n            elif \"SingleRepeat\" in line:\n                singleRepeat = True\n                dictToReturn[prescriptionSelected][\"CohortRemoved\"][\"SingleRepeat\"] = dict()\n                dictToReturn[prescriptionSelected][\"RepeatMode\"] = \"SingleRepeat\"\n                repeatFrenquency = splitLineAndRemoveTabsAndSpaces(line)[1]\n                dictToReturn[prescriptionSelected][\"RepeatFrequency\"] = int(repeatFrenquency)\n            elif \"MultipleRepeat\" in line:\n                dictToReturn[prescriptionSelected][\"RepeatMode\"] = \"MultipleRepeat\"\n                repeatFrenquency = splitLineAndRemoveTabsAndSpaces(line)[1]\n                dictToReturn[prescriptionSelected][\"RepeatFrequency\"] = int(repeatFrenquency)\n                \n            # If we get to the part about the cohort removed, it's a bit more tricky\n            # to register\n            # In particular, we will register the cohort removed in the case of a\n            # second pass (via SingleRepeat) in a different nested dictionnary\n            for species in speciesList:\n                if species in line and \"Prescription \" not in line and \"Plant\" not in line:\n                    if not singleRepeat:\n                        dictToReturn[prescriptionSelected][\"CohortRemoved\"][species] = dict()\n                    else:\n                        dictToReturn[prescriptionSelected][\"CohortRemoved\"][\"SingleRepeat\"][species] = dict()\n                    # 3 cases :\n                    # just ages (11-999)\n                    # \"All\" keyword\n                    # ages categories with biomass percent (11-999(90%))\n                    # print(line)\n                    if \"/\" in line: # Just in case their are relative cohort numbers in the file\n                        raise ValueError(\"Do not use relative number of cohort harvested for a given species, like \\\"1/2\\\" or \\\"1/3\\\". Since this script is made to be used with biomass harvest, use things like \\\"11-999(50%)\\\" to harvest half of the biomass of each cohort.\")\n                    elif \"All\" in line or \"all\" in line:\n                        if not singleRepeat:\n                            dictToReturn[prescriptionSelected][\"CohortRemoved\"][species] = \"All\"\n                        else:\n                            dictToReturn[prescriptionSelected][\"CohortRemoved\"][\"SingleRepeat\"][species] = \"All\"\n                    else: # If not all, we have to break appart the age categories\n                        if not singleRepeat:\n                            dictToReturn[prescriptionSelected][\"CohortRemoved\"][species] = list()\n                        else:\n                            dictToReturn[prescriptionSelected][\"CohortRemoved\"][\"SingleRepeat\"][species] = list()\n                        splittedLine = splitLineAndRemoveTabsAndSpaces(line)\n                        # print(splittedLine)\n                        for ageCategory in splittedLine[1:]:\n                            if \"%\" not in ageCategory:\n                                splitAgeCategory = ageCategory.split(\"-\")\n                                # We add a list describing 1) min age of category 2) max age of category 3) % of biomass harvested\n                                if not singleRepeat:\n                                    dictToReturn[prescriptionSelected][\"CohortRemoved\"][species].append([int(splitAgeCategory[0]), int(splitAgeCategory[1]), 100])\n                                else:\n                                    dictToReturn[prescriptionSelected][\"CohortRemoved\"][\"SingleRepeat\"][species].append([int(splitAgeCategory[0]), int(splitAgeCategory[1]), 100])\n                            else:\n                                splitAgeCategory = ageCategory.replace(\"(\", \"-\").replace(\"%)\", \"\").split(\"-\")\n                                if not singleRepeat:\n                                    dictToReturn[prescriptionSelected][\"CohortRemoved\"][species].append([int(splitAgeCategory[0]), int(splitAgeCategory[1]), int(splitAgeCategory[2])])\n                                else:\n                                    dictToReturn[prescriptionSelected][\"CohortRemoved\"][\"SingleRepeat\"][species].append([int(splitAgeCategory[0]), int(splitAgeCategory[1]), int(splitAgeCategory[2])])\n                        \n            if \"HarvestImplementations\" in line:\n                break\n                \n    return(dictToReturn, timestepLength)\n\nNow, I’ve shown a function to read the stands, and one to read the B. Harvest parameter text file; but how do we get the vegetation data ? How do we know exactly what’s inside each cell in the landscape ? The age cohorts and their biomass ? Took me a while, but I found a great way. There is an output extension called \n\nBiomass Community Output that, at each time step, exports the entire landscape as a raster map + a communities csv file that is exactly like the ones that are used for the initial conditions of LANDIS-II. These files are very large, as they contain the most “raw” data that LANDIS-II can output. But with a bit of optimisation, Python can read them very quickly and put them into a dictionnary. In this dictionnary, we can access the age cohorts of each pixels of a given stand, their age, and their biomass. That gives us all of the information we will ever need to make management decisions.def readCommunitiesComplete(communityCsvPath,\n                            communityMapPath,\n                            standCoordinatesDict,\n                            disableTQDM):\n    \"\"\"\n    Reads the communities csv and raster map made by Output Biomass Community\n    to make a dictionnary containing the species and age cohorts for each\n    species and biomass for these cohorts for all of the pixels of a stand.\n    WARNING : the dictionnary doesn't contain entries for stands that have\n    no cohorts/no biomass, and no entries for species that are not in a stand\n    or cohorts that do not exist for a species. This saves on a lot of space,\n    but one got to check if the entries are there when using the dictionnary.\n    \"\"\"\n\n    # communityCsvPath = \"./community-input-file-\" + str(timestep) + \".csv\"\n    # communityMapPath = \"./output-community-\" + str(timestep) + \".img\"\n    print(\"Reading communities csv and map...\")\n    # We only need the mapcode column from the csv from now.\n    communityCsv = pd.read_csv(communityCsvPath, usecols=['MapCode'])\n    communityMapCodeData = getRasterData(communityMapPath)\n\n    # We make the dictionnary of the amount of times a stand is associated\n    # to a mapcode\n    print(\"Creating mapcode community dictionnary...\")\n    dictMapCodeStands = dict()\n    for uniqueMapCode in communityCsv[\"MapCode\"].unique():\n        dictMapCodeStands[uniqueMapCode] = dict()\n        \n    for standID in standCoordinatesDict.keys():\n        for pixel in standCoordinatesDict[standID]:\n            mapcode = communityMapCodeData[pixel]\n            # If the mapcode is not already in the dictionnary, it was not in\n            # the CSV; and if it's not in the CSV, it's because it's a mapcode\n            # associated to no cohorts at all(total biomass of 0)\n            if mapcode in dictMapCodeStands:\n                if standID not in dictMapCodeStands[mapcode]:\n                    dictMapCodeStands[mapcode][standID] = 1\n                else:\n                    dictMapCodeStands[mapcode][standID] += 1\n    \n    # Now, we can read the CSV file and fill in a second dictionnary with the\n    # information for each stand\n    # To lighten it, we won't put stands that have no biomass\n    # (IMPORTANT FOR OTHER FUNCTIONS : have to check if stand is in dictionnary)\n    print(\"Creating stand community dictionnary...\")\n    \n    standCommunitiesDict = dict()\n    with open(communityCsvPath, 'r') as file:\n        reader = csv.reader(file)\n        headers = next(reader)  # Read the header row\n        for row in tqdm(reader, total=len(communityCsv[\"MapCode\"]), disable = disableTQDM):\n            # 0 is mapcode; 1 is species; 2 is cohort; 3 is biomass.\n            for standID in dictMapCodeStands[int(row[0])]:\n                if standID not in standCommunitiesDict:\n                    standCommunitiesDict[standID] = dict()\n                    standCommunitiesDict[standID][row[1]] = dict()\n                    standCommunitiesDict[standID][row[1]][int(row[2])] = 0\n                # If species not indicated for this stand, we put it\n                elif row[1] not in standCommunitiesDict[standID]:\n                    standCommunitiesDict[standID][row[1]] = dict()\n                    standCommunitiesDict[standID][row[1]][int(row[2])] = 0\n                # If age cohort not indicated for this stand/species, we put it\n                elif int(row[2]) not in standCommunitiesDict[standID][row[1]]:\n                    standCommunitiesDict[standID][row[1]][int(row[2])] = 0\n                # Finally, we enter the biomass for the stand/species/cohort\n                # If the stand has multiple pixel with this mapcode, we multiply\n                # the biomass with the number of pixels\n                # WARNING : Need to transform biomass from g/m2 to Mg/ha by dividing by 100\n                standCommunitiesDict[standID][row[1]][int(row[2])] += (int(row[3])/100)*dictMapCodeStands[int(row[0])][standID]\n        \n    return(standCommunitiesDict)\n\nWe then have other functions that can retrieve data we might need for management decisions. These functions used objects created by other functions that contain data about the vegetation. For example :\n\nGetting the biomass of a list of species we want to harvest in a stand (based on the vegetation data we have put in a dictionnary)def GetBiomassInstand(standCompositionDict, standID, listOfSpecies):\n    \"\"\"Retrieves the total biomass in a stand for a list of species.\n    Returns a single biomass value.\"\"\"\n    sumOfBiomass = 0\n    for species in listOfSpecies:\n        if species in standCompositionDict[standID]:\n            sumOfBiomass += sum(standCompositionDict[standID][species].values())\n    return(sumOfBiomass)\n\nReading the age of the stands (to see what stand are the oldest)def readingStandsAges(standMapPath, maxAgeMapsFolderPath, timestep, timestepLength, disableTQDM):\n    '''Uses the stand maps and max age map to compute the mean age of each stand\n    (average of the age of the oldest cohorts in each pixels of the stand).\n    Returns a dictionnary associating an age to a stand ID.\n    The max age map is taken from the previous timestep to the current one.'''\n    print(\"Reading stands age...\")\n    \n    standData = getRasterData(standMapPath)\n    uniqueAllStandsID = np.unique(standData).tolist()\n    # id 0 for stands = no forests\n    uniqueAllStandsID.remove(0)\n    cohortMaxAgeData = getRasterData(maxAgeMapsFolderPath + \"AGE-MAX-\" + str(timestep - timestepLength) + \".img\")\n    maxAgeDict = dict()\n    # Little trick to use the power of numpy below\n    # We make an array with the pixels we want the value of, and another\n    # with the values\n    pixelCoordinates = np.where(standData != 0)\n    standIDinPixelCoordinates = standData[pixelCoordinates]\n    for standID in tqdm(uniqueAllStandsID, disable = disableTQDM):\n        maxAgeDict[standID] = list()\n    # We get the data for the harvestable pixels\n    cohortMaxAgeInForestPixel = cohortMaxAgeData[pixelCoordinates]\n    # We fill the dictionnary with the different values of max cohort age for each\n    # pixels in a stand\n    for i in tqdm(range(0, len(pixelCoordinates[0])), disable = disableTQDM):\n        maxAgeDict[standIDinPixelCoordinates[i]].append(cohortMaxAgeInForestPixel[i])\n    # We make a dictionnary containing the mean max age for each stand\n    standAgeDict = dict()\n    for standID in tqdm(uniqueAllStandsID, disable = disableTQDM):\n        standAgeDict[standID] = statistics.mean(maxAgeDict[standID])\n    return(standAgeDict)\n\nReading the management unit associated to each stand (remember that we are going to give non-sensical management area maps to B. Harvest if we want to control its behaviour, but we might still want to use management areas in our Python script to make our management decisions)def readingStandManagementUnit(standMapPath, managementUnitsMapPath, disableTQDM):\n    '''Assign a management unit (UA) code to each stand. This is not used to define\n    management units per say in our landscape, but rather to get the conversion\n    values from raw to net merchantable volume harvested, based on data from\n    the ministry of forest (the data changes by species and by management unit).\n    See coefficientRawToNetVolumes object for more info.'''\n    print(\"Reading stands management units (used for volume conversion)...\")\n    \n    standData = getRasterData(standMapPath)\n    uniqueAllStandsID = np.unique(standData).tolist()\n    # id 0 for stands = no forests\n    uniqueAllStandsID.remove(0)\n    managementUnitsMap = getRasterData(managementUnitsMapPath)\n    managementUnitDict = dict()\n    # Little trick to use the power of numpy below\n    # We make an array with the pixels we want the value of, and another\n    # with the values\n    pixelCoordinates = np.where(standData != 0)\n    standIDinPixelCoordinates = standData[pixelCoordinates]\n    for standID in tqdm(uniqueAllStandsID, disable = disableTQDM):\n        managementUnitDict[standID] = list()\n    # We get the data for the harvestable pixels\n    managementUnitInPixel = managementUnitsMap[pixelCoordinates]\n    # We fill the dictionnary with the different values of max cohort age for each\n    # pixels in a stand\n    for i in tqdm(range(0, len(pixelCoordinates[0])), disable = disableTQDM):\n        managementUnitDict[standIDinPixelCoordinates[i]].append(managementUnitInPixel[i])\n    # We make a dictionnary containing the mean max age for each stand\n    standManagementUnitDict = dict()\n    for standID in tqdm(uniqueAllStandsID, disable = disableTQDM):\n        standManagementUnitDict[standID] = Counter(managementUnitDict[standID]).most_common(1)[0][0]\n    return(standManagementUnitDict)\n\nWriting in the raster map that we are going to create what pixels will be harvested with a given prescriptionsdef harvestStands(managementMap, standsList, standCoordinatesDict, prescriptionID):\n    \"\"\"Edits the management map to indicate a list of stands as harvested with\n    a given prescription ID. Returns the modified management map.\"\"\"\n    numberOfPixelsHarvested = 0\n    for standID in standsList:\n        for pixel in standCoordinatesDict[standID]:\n            managementMap[pixel] = prescriptionID\n            numberOfPixelsHarvested += 1\n    return(managementMap, numberOfPixelsHarvested)\n\nA function to get what are the stands that are the neighbours of a stand if we want to propagate a cut accross several standdef readingStandsNeighbors(standRasterDataAll,\n                           standCoordinatesDict,\n                           disableTQDM = True):\n    '''Reads the neighbors of each stand by looking at the surrounding\n    pixels of those of the stands, and getting their stand ID. Returns a dictionnary\n    with the list of neighbors's stand ID for each stand.'''\n    print(\"Reading stand neighbors...\")\n    \n    # Making a dictionnary which tells what stand is a neighbor of which one.\n    # We only need it for harvestable stands, since this is for the propagation\n    # of cuts.\n    standNeighboursDict = dict()\n    minXRange = range(standRasterDataAll.shape[0])[0]\n    maxXRange = range(standRasterDataAll.shape[0])[-1]\n    minYRange = range(standRasterDataAll.shape[1])[0]\n    maxYRange = range(standRasterDataAll.shape[1])[-1]\n    for standID in tqdm(standCoordinatesDict.keys(), disable = disableTQDM):\n        listOfNeighbouringStands = list()\n        for pixel in standCoordinatesDict[standID]:\n            listOfStandsAroundPixel = list()\n            # We look at the 8 neighbors of the pixel, if not out of range,\n            # to try to detect another stand number\n            # First, we prepare the ranges around which we'll loop, and make sure\n            # we're not out of bounds\n            xMinus1 = max(pixel[0] - 1, minXRange)\n            xPlus1 = min(pixel[0] + 1, maxXRange)\n            yMinus1 = max(pixel[1] - 1, minYRange)\n            yPlus1 = min(pixel[1] + 1, maxYRange)\n            # Now, we loop to find values\n            for x in [xMinus1, pixel[0], xPlus1]:\n                for y in [yMinus1, pixel[1], yPlus1]:\n                    listOfStandsAroundPixel.append(standRasterDataAll[(x, y)])\n            uniqueNeighbouringStands = set(listOfStandsAroundPixel)\n            # We remove mentions of the present stand and of the value 0\n            uniqueNeighbouringStands.discard(standID)\n            uniqueNeighbouringStands.discard(0)\n            listOfNeighbouringStands.extend(list(uniqueNeighbouringStands))\n        # We add the resulting unique standID that we found as neighbors to this stand\n        standNeighboursDict[standID] = set(listOfNeighbouringStands)\n    return(standNeighboursDict)\n\nA function to propagate the cuts from stand to stand until we reach a certain sizedef standHarvestPropagation(standID,\n                            prescription,\n                            prescriptionParameters,\n                            standNeighboursDict,\n                            standCoordinatesDict,\n                            standAgeDict):\n    \"\"\"\n    Propagate a harvest prescription from a stand to the neigbouring stands,\n    depending on the selection criteria + min/max harvest size for the\n    prescription.\n    Returns a list of harvested stands.\n    \"\"\"\n    listOfHarvestedStands = list()\n    frontier = [standID]\n    surfaceHarvested = 0\n    while surfaceHarvested < prescriptionParameters[prescription][\"HarvestPropagation\"][1] and len(frontier) > 0:\n        focusStand = frontier.pop(0)\n        # If we overeach the maximum surface, we stop here.\n        if surfaceHarvested + len(standCoordinatesDict[focusStand]) > prescriptionParameters[prescription][\"HarvestPropagation\"][1]:\n            break\n        else:\n            listOfHarvestedStands.append(focusStand)\n            # TO UPDATE : Surface harvested here is dealt in pixels. But in harvest parameter\n            # file, might be in different units than pixel. See how to adapt to that. Need cell length ?\n            surfaceHarvested += len(standCoordinatesDict[standID])\n            for neighbor in standNeighboursDict[focusStand] :\n                if neighbor not in listOfHarvestedStands and standAgeDict[neighbor] > prescriptionParameters[prescription][\"MinimumStandAge\"] and standAgeDict[neighbor] < prescriptionParameters[prescription][\"MaximumStandAge\"]:\n                   frontier.append(neighbor) \n    return(listOfHarvestedStands)\n\nI won’t discuss all of the functions that are in the template, but there are a lot of them !\n\nSo as you see, the first section of this template contains a lot of functions. Many of them actually replace functions that are inside B. Harvest; reading the position of the stands, their age, etc. Again, the trade-off is that here, we have the freedom to do anything we want, but have to re-do it from A to Z. It’s like we’re writing an entire new model in our script. And that’s why these functions are here. The good news is : you won’t have to worry about them one bit ! They’re already ready. So a big, big chunk of the work is already done for you.\n\nAnother cool thing : it’s very easy to test these functions, to understand them or to create news ones ! Python is an intepreted langage like R, so you can run commands and interact with it easily. So, you can put your script in a folder containing LANDIS-II inputs and outputs, and you can try it out and see if it works line by line. This makes creating your algorithm and debugging it VASTLY easier than working in C#. In fact, you’ll see in the template a little section that allow you to run the script in “debug mode”.#%% DEBUG\n\n# Just put \"False\" unless you're tinkering with this script.\ndebug = False\n# debug = True\n\n# If debugging, we prepare a dummy situation\nif debug:\n    os.chdir(r\"path/to/your/folder/with/simulation/files/landis-ii\")\n    timestep = 15\n    BAU_Modifier = 1\n    disableTQDM = False\n    import matplotlib.pyplot as plt\nelse:\n    # If not debugging, this Python script is normally called in a command prompt by specifying\n    # some arguments, like the location of the folders containing the files that\n    # we need relative to the LANDIS-II scenario file\n    if __name__ == \"__main__\":\n        # Remember : argument at index 0 contains the program name.\n        # The arguments that we want come after\n        timestep = sys.argv[1]\n        timestep = int(timestep)\n        # You can retrieve other arguments here; just use sys.argv[2], sys.argv[3], etc. \n    # We disable the progress bars of TQDM to not display them in the LANDIS log\n    disableTQDM = True\n\nIf not in debug mode, you’ll see (see code snippet above) that the script will attempt to gather “arguments” that were given with the command; here, I’m taking the {timestep} argument i’ve passed through the Magic Harvest Parameter text file from earlier (which Magic Harvest will transform into the LANDIS-II time step at which the script is launched). This way, I have a variable in my script that contains the current time step. There are other ways to get the current time step - for example, by looking at LANDIS-II output files - but this one is the simplest and most reliable in my opinion.","type":"content","url":"/lookingatthingsinpractice#defining-functions-for-everything","position":9},{"hierarchy":{"lvl1":"Using Magic Harvest in practice","lvl3":"Using functions to read the state of the landscape","lvl2":"Taking a look at a Python script template"},"type":"lvl3","url":"/lookingatthingsinpractice#using-functions-to-read-the-state-of-the-landscape","position":10},{"hierarchy":{"lvl1":"Using Magic Harvest in practice","lvl3":"Using functions to read the state of the landscape","lvl2":"Taking a look at a Python script template"},"content":"The second section of the script is then using the functions we’ve just looked at to read files and load the informations of the landscape into Python variables, especially Python dictionnaries.#%% DEFINING PARAMETERS FOR EACH PRESCRIPTION\n\n# We read the template harvest parameter file, which also contains the parameters needed\n# for magic harvest\nprescriptionParameters, timestepLength = harvestParameterFileParser(\"./input/disturbances/harvesting/harvest_BAU_v2.0_TEMPLATE.txt\")\n\n#%% READING DATA FOR TIME STEP\n\n# Reading files for stand coordinates\nstandRasterData = getRasterData(\"../../sharedRasters/stands_v2.0.tif\")\nstandCoordinatesDict = readingStandsCoordinates(standRasterData,\n                                                disableTQDM)\n\n# Reading raster of Management units (UAs)\nstandUADict = readingStandManagementUnit(\"../../sharedRasters/stands_v2.0.tif\",\n                                         \"../../sharedRasters/rasterUAInterpolated.tif\",\n                                         disableTQDM)\n\n# Reading JSON files for repeated prescriptions\nrepeatPrescriptionPath = \"./input/disturbances/harvesting/temp/repeatedPrescriptions.pickle\"\nif os.path.exists(\"repeatPrescriptionPath\"):\n    with open(repeatPrescriptionPath) as repeatedPrescriptionFile:\n        pickle.load(repeatPrescriptionsDict, repeatedPrescriptionFile)\nelse:\n    repeatPrescriptionsDict = \"noRepeatsForNow\"\n\n# Reading vegetation communities\nstandCompositionDict = readCommunitiesComplete(\"./community-input-file-\" + str(timestep- timestepLength) + \".csv\",\n                                            \"./output-community-\" + str(timestep- timestepLength) + \".img\",\n                                            standCoordinatesDict,\n                                            disableTQDM)\n\n# Reading stand ages\nstandAgeDict = readingStandsAges(\"../../sharedRasters/stands_v2.0.tif\",\n                         \"./output/cohort-stats/\",\n                         timestep,\n                         timestepLength,\n                         disableTQDM)\n\n# Determining forest types\nforestTypesStandsDict = DetermineForestTypesOfStands(standCompositionDict,\n                                                     standCoordinatesDict,\n                                                     disableTQDM)\n\n# Determining management unit for each stand (used for the conversion of\n# raw to net merchantable volume harvested)\n\n# stand neighbors dict (used for stand propagation)\nstandNeighboursDict = readingStandsNeighbors(standRasterData,\n                                            standCoordinatesDict,\n                                            disableTQDM)\n\nYou might notice that one of these parts deals with repeated prescriptions. So in B. Harvest, you can have prescription that will periodically come back to a given stand - like long-term uneven-aged management or partial cuts -, or come from a second final cut - like the shelterwood method. Again, B. Harvest deals with all through the internal variables of LANDIS-II, in the RAM of the computer. However, the Python script that we run at every time step with Magic Harvest doesn’t have a permanent memory; when the script will finish for a given timestep, it will unload its variables. So, if you want to keep information saved for your script to re-load it at the next time step - for example, the list of stands that have repeated prescriptions so that you know which one to re-harvest periodically in the future - , you’ll have to save this in a file.\n\nPython makes that easy, with many choices : you can export Python objects - like Python dictionnaries - into a .json file, which is a popular format that is human-readable - meaning that you can open the file and read it yourself. You can also save it in “Pickle” format, which is not human readable, but which is made to save and load python objects easily. I recommand the pickle format for complex objects, and the Json format for simpler ones.\n\nHere is the code used later in the script (in the section where outputs are done) :# We save the pickle file with the data for the next repeated harvests\n# Wanted to use JSON, but doesn't work well with the complex dictionnaries I use.\n# WARNING : pickle is not human-readable. It is made to be read by a Python script.\nif repeatPrescriptionsDict!= \"noRepeatsForNow\":\n    with open('./input/disturbances/harvesting/tempMagicHarvest/repeatedPrescriptions.pickle', \"wb+\") as outfile:\n        pickle.dump(repeatPrescriptionsDict, outfile)\n\nYou can see that there are also a couple of lines to remove the files made by the Biomass Community extension, and which contain all of the vegetation data at the end of the previous timestep (and so, if Magic Harvest is the first disturbance extension to run, it’s also the state of the current time step before anything happens). These files are very heavy, so you might want to remove them once you’re done reading them.# Removing vegetation communities files if needed\nif not debug and removeCommunitiesFiles:\n    if os.path.exists(\"./output-community-\" + str(timestep- timestepLength) + \".img\"):\n        os.remove(\"./output-community-\" + str(timestep- timestepLength) + \".img\")\n    if os.path.exists(\"./community-input-file-\" + str(timestep- timestepLength) + \".csv\"):\n        os.remove(\"./community-input-file-\" + str(timestep- timestepLength) + \".csv\")\n    if os.path.exists((\"./community-input-file-\" + str(timestep- timestepLength) + \".csv\")[0:-3] + \"txt\"):\n        os.remove((\"./community-input-file-\" + str(timestep- timestepLength) + \".csv\")[0:-3] + \"txt\")\n\nYou can also see that there is a line preparing a two dimensional numpy array with the same dimensions as the management area map, but filled with zeroes. This is the array we will fill with the location of the pixels we want to harvest precisely, and that we will use to create the management raster that we will feedback to B. Harvest to control its harvesting, as I explained before.#%% PREPARING OTHER OBJECTS WE NEED\n\n# We prepare the empty management map that we will fill with the values of the pixels where we want to harvest.\nmanagementMap = np.zeros_like(getRasterData(\"../../sharedRasters/stands_v2.0.tif\"))","type":"content","url":"/lookingatthingsinpractice#using-functions-to-read-the-state-of-the-landscape","position":11},{"hierarchy":{"lvl1":"Using Magic Harvest in practice","lvl3":"Making the management decisions","lvl2":"Taking a look at a Python script template"},"type":"lvl3","url":"/lookingatthingsinpractice#making-the-management-decisions","position":12},{"hierarchy":{"lvl1":"Using Magic Harvest in practice","lvl3":"Making the management decisions","lvl2":"Taking a look at a Python script template"},"content":"Now that everything is loaded, this is the part where you can do your management decisions. Here, as this script is a template, this part is empty. We’re going to do some exercises together afterward to explore what we can do here. But sky’s the limit. The only thing we have to do is to fill the array that will be used to output our management map, where each pixel contains the code of the prescription we want to apply in this pixel. The rest is up to our imagination.#%% MAKING THE HARVEST DECISIONS\n\n# This is where you should write functions that will define where you want to harvest.\n# So, doing your repeated prescriptions, ranking the stands and then applying new prescriptions until you \n# reach a given target, etc., etc.\n","type":"content","url":"/lookingatthingsinpractice#making-the-management-decisions","position":13},{"hierarchy":{"lvl1":"Using Magic Harvest in practice","lvl3":"Creating the outputs to control Biomass Harvest and others","lvl2":"Taking a look at a Python script template"},"type":"lvl3","url":"/lookingatthingsinpractice#creating-the-outputs-to-control-biomass-harvest-and-others","position":14},{"hierarchy":{"lvl1":"Using Magic Harvest in practice","lvl3":"Creating the outputs to control Biomass Harvest and others","lvl2":"Taking a look at a Python script template"},"content":"The final section is simply the creation of the outputs. We create an object containing information about the repeated prescription for the next; we create the raster map to give to B. Harvest to control its harvesting using the array we filled before; and we then edit the parameter text file of B. Harvest to add new prescriptions if we want to, indicate the name of this new management map we’re giving him, and also to write the implementation table to force him to harvest 100% of each pixel codes we have put in the map, as I’ve described before. The template also writes a couple of log files to help reading what happenned after the simulation.#%% OUTPUTS\n\n# This is where we create the files that we will give back to Biomass Harvest\n\nprint(\"Creating outputs...\")\n\n# We prepare the folder with temporary files\nif not os.path.exists(\"./input/disturbances/harvesting/tempMagicHarvest/\"):\n    os.mkdir(\"./input/disturbances/harvesting/tempMagicHarvest/\")\n\n# We save the pickle file with the data for the next repeated harvests\n# Wanted to use JSON, but doesn't work well with the complex dictionnaries I use.\n# WARNING : pickle is not human-readable. It is made to be read by a Python script.\nif repeatPrescriptionsDict!= \"noRepeatsForNow\":\n    with open('./input/disturbances/harvesting/tempMagicHarvest/repeatedPrescriptions.pickle', \"wb+\") as outfile:\n        pickle.dump(repeatPrescriptionsDict, outfile)\n\n# Create harvest maps\nprint(\"Magic harvest Python script : WRITING PRESCRIPTION MAP\")\nwriteNewRasterData(managementMap,\n                    \"../../sharedRasters/stands_v2.0.tif\",\n                    \"./input/disturbances/harvesting/tempMagicHarvest/prescriptions-\" + str(timestep) + \".tif\")\n\n# Create harvest txt file\n# We add to the txt file :\n# - The new plantation prescriptions\n# - The surface to harvest for each prescription ID / fake management areas to contrain harvesting\nwriteHarvestParameterFile(managementMap,\n                            \"/input/disturbances/harvesting/\",\n                            \"harvest_BAU_v2.0_TEMPLATE.txt\",\n                            \"harvest_BAU_v2.0.txt\",\n                            prescriptionParameters,\n                            \"./input/disturbances/harvesting/tempMagicHarvest/prescriptions-\" + str(timestep) + \".tif\",\n                            timestep)\n\n# Update table that gives the prescription names for each prescription ID\n# for easy identification in GIS softwares of the harvest output maps\nWriteTableOfPrescriptionsID(\"./input/disturbances/harvesting/tempMagicHarvest/prescriptionIDTable-\" + str(timestep) + \".csv\",\n                            prescriptionParameters)\n\n# We make a log of the harvested surfaces and volumes.\ncsvFileOutputPath = \"./output/magicHarvest/logMagicHarvest.csv\"\n\n\n# If first timestep, we create the file.\nif timestep == timestepLength:\n    if os.path.exists(csvFileOutputPath):\n        os.remove(csvFileOutputPath)\n    \n    # We make the output directories if they don't already exist\n    if not os.path.exists(os.path.dirname(csvFileOutputPath)):\n        os.makedirs(os.path.dirname(csvFileOutputPath))\n        \n    listOfHeaders = [\"Timestep\", \"Surface Harvested\"]\n    for target in volumeTargetDicts:\n        listOfHeaders.append(\"Volume \" + str(target) + \" harvested\")\n    \n    with open(csvFileOutputPath, 'w+', newline='') as file:\n        writer = csv.writer(file)\n        writer.writerow(listOfHeaders)\n\n# Then, we write the values\nnewRow = [str(timestep), str(np.count_nonzero(managementMap))]\nfor target in volumeTargetDicts:\n    newRow.append(str(volumeTargetCounterDict[target]))\nwith open(csvFileOutputPath, 'a', newline='') as file:\n    writer = csv.writer(file)\n    writer.writerow(newRow)\n\nAnd that’s it ! Once the script is over, Magic Harvest will force B. Harvest to re-load its parameters, and B. Harvest will then activate and harvest the pixels in the way we told him.\n\nOf course, there are many functions that you could add to the template; for example, functions to read the rasters from other disturbances extensions (like fire and insect epidemics) to then know where to do salvage logging. Don’t feel restricted by what I’ve described here. In fact, we’re now going to finish by making you use your imagination a bit !","type":"content","url":"/lookingatthingsinpractice#creating-the-outputs-to-control-biomass-harvest-and-others","position":15},{"hierarchy":{"lvl1":"Using Magic Harvest in practice","lvl2":"Conclusion about using Magic Harvest in practice"},"type":"lvl2","url":"/lookingatthingsinpractice#conclusion-about-using-magic-harvest-in-practice","position":16},{"hierarchy":{"lvl1":"Using Magic Harvest in practice","lvl2":"Conclusion about using Magic Harvest in practice"},"content":"You should now have a pretty good idea of how using Magic Harvest works in term of using files; or at least inspiration to do your own script and run them in LANDIS-II.\n\nWe’re going to finish by doing a couple of exercises to train your imagination to write some algorithms to make your management decisions through a script.","type":"content","url":"/lookingatthingsinpractice#conclusion-about-using-magic-harvest-in-practice","position":17},{"hierarchy":{"lvl1":"Exercices"},"type":"lvl1","url":"/exercises","position":0},{"hierarchy":{"lvl1":"Exercices"},"content":"Authors: Clément Hardy1 Affiliations: 1Université du Québec en Outaouais (UQO)\\\n\n","type":"content","url":"/exercises","position":1},{"hierarchy":{"lvl1":"Exercices","lvl2":"Thinking about what you can do with Magic Harvest"},"type":"lvl2","url":"/exercises#thinking-about-what-you-can-do-with-magic-harvest","position":2},{"hierarchy":{"lvl1":"Exercices","lvl2":"Thinking about what you can do with Magic Harvest"},"content":"The three exercices that I propose here will not ask you to code in any programming langage.\n\nWhat I’m going to do is ask you to write step-by-step algorithms in plain english about what a possible script used with Magic Harvest (whatever the programming langage you choose down the road) will be used for different use case.\n\nIn that way, when you’ll try to use Magic Harvest for your own research, I hope that you’ll have a general idea of what you’ll want to do with it. The implementation of your algorithm in a programming - the coding part - is not necesseraly the most complex thing to do, especially with the new AI tools that are accessible today.","type":"content","url":"/exercises#thinking-about-what-you-can-do-with-magic-harvest","position":3},{"hierarchy":{"lvl1":"Exercices","lvl2":"Example of an algorithm in plain english"},"type":"lvl2","url":"/exercises#example-of-an-algorithm-in-plain-english","position":4},{"hierarchy":{"lvl1":"Exercices","lvl2":"Example of an algorithm in plain english"},"content":"\n\nHere is an example of the kind of algorithm I propose that you’ll write in the following exercises, in plain english.\n\nHere, we’ll simply write the algorithm for a script that will do the following :\n\nWe want to do repeated partial cutting every 30 years for 90 years, and simple clearcutting in a landscape : So here, what we want to do is to harvest a certain percentage of the target with partial cutting, which demands that when we select a stand for harvesting with partial cutting, we have to come back every 30 years to harvest it until we reach 90 years, and then we stop coming back.\n\nHere is the resulting algorithm in plain english to write a script that will do this with Magic Harvest :\n\nRead the state of the landscape and put it in variables\n\nDefine or read target of hectares to harvest with partial cutting and clear cutting\n\nRead a file containing information about stands that have been registered with repeated partial cutting and put it in a variable\n\nFor each stand registered for repeated partial cutting :\n\nCheck if this year should be a year where the given stand is harvested with partial cutting (period of 30 years)\n\nIf it is the case, write the code corresponding to partial cutting in the management map for all of the pixels of the stand, and then record the - next time that the stand should be harvested in the variable\n\nIf not, do nothing.\n\nCheck if the stand has reached its last partial cutting (90 years are done)\n\nIf so, remove the stand from the variable\n\nCheck if we need to add new stands to list of regular partial cutting reach the % of hectare harvested each year with partial cutting\n\nIf that’s the case, rank the stands in the landscape based on their biomass.\n\nThen, select stands starting with those with a lot of biomass until we reach the target. Add each of these stands to the list of repeated partial-  cutting.\n\nThen, look at all of the stands in the landscape and rank them by biomass\n\nFor each stand, looking at those with the most biomass first, register them for harvesting with clearcutting in the management map for all of the-  pixels of the stand\n\nStop when we have reached the target of hectares to harvest with clearcutting\n\nExport the management map and edit the parameter files of B. Harvest.","type":"content","url":"/exercises#example-of-an-algorithm-in-plain-english","position":5},{"hierarchy":{"lvl1":"Exercices","lvl2":"First exercise - Salvage logging"},"type":"lvl2","url":"/exercises#first-exercise-salvage-logging","position":6},{"hierarchy":{"lvl1":"Exercices","lvl2":"First exercise - Salvage logging"},"content":"\n\nLet’s start simple : we’re going to do salvage logging.\n\nWe want that when a fire happens in the landscape, B. Harvest will go and harvest 70% all stands impacted by the fire (remember that a stand is a group of pixels in LANDIS-II). The prescription we will used called “salvage logging” will be pre-defined in the B. Harvest parameter text file, so we do not need to create it in the script. The rest of the harvesting for the current timestep will be left to B. Harvest to decide; so here, we do not take complete control.\n\nBasically, that means that we are going to take the fire map created by one of the fire extensions of LANDIS-II; the management area map of B. Harvest; and we’re going to merge the two to create a new management area corresponding to the fire. Then, we’ll have to make sure that B. Harvest will harvest 70% of the surfaced of this new management area with the salvage logging prescription.\n\nSolution to \n\nExercise 1\n\nHere is the resulting algorithm in plain english to write a script that will do this with Magic Harvest.\n\nThe solution here is relatively simple, because we’re letting Biomass Harvest take a lot of decisions.\n\n\n\nRead latest fire map\n\nEdit the management area map to create a new one on the disturbance\n\nEdit the biomass harvest parameter file to make sure it will read the new map and edit its implementation table to add a new line to harvest 70% of the stands or of the surface of the new management area","type":"content","url":"/exercises#first-exercise-salvage-logging","position":7},{"hierarchy":{"lvl1":"Exercices","lvl2":"Second exercise - Clearcutting, Partial cutting and protected areas"},"type":"lvl2","url":"/exercises#second-exercise-clearcutting-partial-cutting-and-protected-areas","position":8},{"hierarchy":{"lvl1":"Exercices","lvl2":"Second exercise - Clearcutting, Partial cutting and protected areas"},"content":"\n\nWe want to harvest with clearcutting and partial cutting until we reach a target of biomass. Not a target of surface, but a target of biomass. So here, we’re taking complete control of what pixels and stands we will harvest, and we will make all of the decision to choose them. But we will stop when we have reached enough biomass harvest - something that B. Harvest cannot do, because B. Harvest cannot use biomass targets, only surface ! We will harvest 70% of the target of biomass with clearcutting, and then 30% with partial cutting. We will prioritize stands with the most biomass in them, but we will avoid stands located in protected areas.\n\nSo, we’re going to read the stands in the landscapes; define a biomass target (it doesn’t matter the number, just know that we have one); we’re going to rank the stands, and then select stands with clearcutting or partial cutting until 70% of the biomass target is harvested with clearcutting, and 30% with partial cutting. And of course, we’ll be mindful of the protected areas.\n\nThis one is going to be much more complex since we’re taking complete control of what pixels will be harvested exactly. Take your time; you will surely encounter problems as you go forwards, for which you will have to go back and edit the beginning of your algorithm to get things ready for the rest.\n\nSolution to \n\nExercise 2\n\nRead the position of the stands and their composition in terms of vegetation/age cohorts and their biomass\n\nRead the location of protected areas, and create an object that defines if a stand is in a protected area or not\n\nRead or define in the script how clearcutting and partial cutting are done so that we can estimate the biomass harvested when we apply it to a - stand\n\nPrepare an empty management map filled with zeroes\n\nDefine the overall biomass target\n\nHarvest 70% with clearcutting :\n\nRank the stand in the landscape based on their biomass\n\nCreate a list of stands harvested with clearcutting\n\nAdd stands to the clearcutting list one by one in ranking order\n\nCheck everytime if a stand is in a protected area. If it is not, then do not add it to the list\n\nEstimate the biomass that will be harvested with the clearcutting in each given stand, and compute a sum\n\nWhen the sum reaches 70% of the biomass target, stop the loop.\n\nHarvest 30% with partial cutting :\n\nSame thing as with clearcutting : Rank stands according to biomass, add them to the list if they are not in a protected area or already - - - harvested by clearcutting. Compute the biomass that will be harvested by partial cutting everytime we add a stand to the list, and compute the - sum. When sum reaches 30% of the biomass target, stop the loop.\n\nFor both the clearcutting and partial cutting list, look at each stand in both list\n\nFor each pixels of the stand, write the code corresponding to either clearcutting or partial cutting in the pixels of the management map\n\nExport the management map as a raster map\n\nEdit the biomass harvest parameter file to make sure it will read the new management map as both its management area raster and stand raster, and edit its implementation table to add two new lines to harvest 100% of the pixels corresponding to the code of clearcutting and partial - cutting with the respective prescription.","type":"content","url":"/exercises#second-exercise-clearcutting-partial-cutting-and-protected-areas","position":9},{"hierarchy":{"lvl1":"Exercices","lvl2":"Third exercise - Clearcutting and complex planting of rare species"},"type":"lvl2","url":"/exercises#third-exercise-clearcutting-and-complex-planting-of-rare-species","position":10},{"hierarchy":{"lvl1":"Exercices","lvl2":"Third exercise - Clearcutting and complex planting of rare species"},"content":"\n\nWe want to harvest a biomass target with clearcutting like we did before. But in a random 20% of the stands that we will harvest with clearcutting, we will do enrichment planting and add 2 rare species in the stand. We will add distribute these 2 rare species randomly in the cells of the stand, 1 species per cell. These rare species will be chosen based on the composition of the cell : we have a table giving us the priority for planting each of them. But if the rare species is already in the stand, then we will not plant it and choose another of lower priority. We will just do clearcutting to keep things simple, and nothing else. No partial cutting this time. No protected areas either.\n\nSo, like before, we would look at the stands in the landscape, take a biomass target, rank the stands, select stands for harvest with clearcutting until we reach the biomass target; then, we will select 20% of all stands harvested randomly, select 2 rare species to plant, and plant these species randomly in the stand, with one species planted by pixel. And so, we are going to need special prescription of clearcutting + planting because remember : B. Harvest can only do one type of planting by prescription. B. Harvest cannot vary the planting or do conditional planting for one prescription. So here, we have to prepare this for B.Harvest so that they know what to do.\n\nThis is basically what I’ve done in a recent paper (see \n\nHardy et al. 2025), albeit a little different.\n\nSolution to \n\nExercise 3\n\n\n\nRead the position of the stands and their composition in terms of vegetation/age cohorts and their biomass\n\nRead the location of protected areas, and create an object that defines if a stand is in a protected area or not\n\nRead or define in the script how clearcutting is done so that we can estimate the biomass harvested when we apply it to a stand\n\nPrepare an empty management map filled with zeroes\n\nPrepare an object to record new clearcutting prescription with different types of planting following the clearcut.\n\nDefine the overall biomass target\n\nSelect the stands to harvest :\n\nRank all of the stands in the landscape according to their biomass.\n\nWe add the stands one by one in their ranking order to the list of stands harvested with clearcutting for the timestep.\n\nFor each stand, we compute the biomass that clearcutting will harvest and we compute the sum.\n\nWe stop when we have reached the biomass target.\n\nWe select 20% of stands randomly in the list of stand harvested with clearcutting.\n\nFor the 80% not selected, we input the code for simple clearcutting (without planting) in the empty management map.\n\nFor the 20% selected for planting, we look at stands one by one.\n\nWe select the 2 species to plant by looking at the composition of the stand and our priority list for planting.\n\nOnce the 2 species are selected, we check if clearcutting prescription with a planting of one of these 2 species already exist in our object to - record new planting prescriptions.\n\nIf it exist, we simply get the code for the two prescriptions that will plant these two species.\n\nIf it doesn’t exist, we create them and generate new codes for them.\n\nWe then distribute the codes for the 2 planting prescriptions randomly in the cells of the stand in the management map, trying to have a 50/50 - ratio between the number of pixels with the first planting prescription and the second.\n\nExport the management map as a raster map\n\nEdit the biomass harvest parameter file to make sure it will read the new management map as both its management area raster and stand raster, - and edit its implementation table to add two new lines to harvest 100% of the pixels corresponding to the code of clearcutting and partial cutting with the respective prescription.","type":"content","url":"/exercises#third-exercise-clearcutting-and-complex-planting-of-rare-species","position":11},{"hierarchy":{"lvl1":"Conclusion"},"type":"lvl1","url":"/conclusion","position":0},{"hierarchy":{"lvl1":"Conclusion"},"content":"Authors: Clément Hardy1 Affiliations: 1Université du Québec en Outaouais (UQO)\\\n\n\n\n\n\nThank you for taking the time to learn to use Magic Harvest ! I hope it’ll be as useful to you as it was to me.\n\nYou might think that this workshop is strangely detailed and complete for such a small extension of a single Forest Landscape Model. Truth is, I had a lot of colleagues and people in the LANDIS-II community asking me about Magic Harvest; and so, I decided to make sure that everybody had a good ressource to learn how to use it in the future.\n\nAs forest ecologists, we are now in great demand to investigate the long-term and large scale effect of forest management. Forest industries, governments and the public at large are desperate to find new ways to do forestry without compromising the health, integrity and complexity of forests.\n\nWhile I do believe that there will be no miracles coming out of this research, and that our societies will most likely need to tune down our level of ressource consumption if we really want to help forest survivre the 21st century (and those that will come after), simulations can still clarifiy a lot of thing on these issues.\n\nMagic Harvest offers you the capability of making complex management strategies in a completely flexible way while profiting from the amazing power of the LANDIS-II model. It basically allows you to couple a complex forest management model with a complex Forest landscape model. In my own experience, this is still really new, and very exciting for many people.\n\nThe sky is the limit : you might make management decisions based on complex algorithms that you will have created, or you might even use external models used in forestry (e.g. Woodstock) to do the decisions and import them back into LANDIS-II.\n\nThe main difficulty of Magic Harvest is not necesseraly to use it, but to use it in conjonction with the rest of LANDIS-II; because all of the other extensions of LANDIS-II need calibrating and parametrizing and all ! LANDIS-II is an awesome model, but it does take time and patience to get it in your mind and have a good view of what’s going on. Luckily, it’s often simpler to understand than other models thanks to its modular nature and its spatially explicit representation of things, which makes it easier to visualize in your mind. But once you’ll get it, you will be a forest ecologist in very high demand. Congratulations for your perseverance !\n\nOne last word : I can answer some questions at \n\nclem.hardy@pm.me, but my time these days is quite limited. Still, feel free to send me a message !\n\nGood luck simulating forests,\n\nClément","type":"content","url":"/conclusion","position":1}]}